From zxombie at berlios.de  Fri Apr  7 04:18:34 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 7 Apr 2006 04:18:34 +0200
Subject: [Libpkg-svn] r85 - trunk/src
Message-ID: <200604070218.k372IYXZ011975@sheep.berlios.de>

Author: zxombie
Date: 2006-04-07 04:18:27 +0200 (Fri, 07 Apr 2006)
New Revision: 85

Modified:
   trunk/src/pkg_util.c
Log:
Execute the contructed string by sending it to system(3)


Modified: trunk/src/pkg_util.c
===================================================================
--- trunk/src/pkg_util.c	2006-03-28 10:37:26 UTC (rev 84)
+++ trunk/src/pkg_util.c	2006-04-07 02:18:27 UTC (rev 85)
@@ -138,15 +138,16 @@
 {
 	va_list ap;
 	char *str;
+	int ret;
 
 	va_start(ap, fmt);
 	vasprintf(&str, fmt, ap);
 	va_end(ap);
 
-	printf("exec: %s\n", str);
+	ret = system(str);
 	free(str);
 
-	return 0;
+	return ret;
 }
 
 /**



From zxombie at berlios.de  Mon Apr 10 01:24:10 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Mon, 10 Apr 2006 01:24:10 +0200
Subject: [Libpkg-svn] r86 - trunk/src
Message-ID: <200604092324.k39NOAhq027942@sheep.berlios.de>

Author: zxombie
Date: 2006-04-10 01:23:55 +0200 (Mon, 10 Apr 2006)
New Revision: 86

Modified:
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_freebsd.c
   trunk/src/pkg_freebsd_private.h
Log:
Rewrite the FreeBSD package backend. The new backend caches more data, is simpler and should be faster.
Move freebsd_format_cmd to pkg_db_freebsd.c as that is where it is being used


Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-07 02:18:27 UTC (rev 85)
+++ trunk/src/pkg_db_freebsd.c	2006-04-09 23:23:55 UTC (rev 86)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005, Andrew Turner, All rights reserved.
+ * Copyright (C) 2005, 2006 Andrew Turner, All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -76,6 +76,8 @@
 				char *ndir);
 pkg_static int			 freebsd_check_contents(struct pkg_db *,
 				struct pkg_freebsd_contents *);
+pkg_static void			 freebsd_format_cmd(char *, int, const char *,
+				const char *, const char *);
 
 /**
  * @defgroup PackageDBFreebsd FreeBSD Package Database handeling
@@ -638,5 +640,85 @@
 }
 
 /**
+ * @brief Creates a string containing the command to run using printf
+ * like substitutions
+ *
+ * @verbatim
+ * Using fmt, replace all instances of:
+ *
+ * %F   With the parameter "name"
+ * %D   With the parameter "dir"
+ * %B   Return the directory part ("base") of %D/%F
+ * %f   Return the filename part of %D/%F
+ * @endverbatim
+ *
+ * @bug Does not check for overflow - caution!
+ */
+static void
+freebsd_format_cmd(char *buf, int max, const char *fmt, const char *dir,
+	const char *name)
+{
+	char *cp, scratch[FILENAME_MAX * 2];
+	int l;
+
+	assert(buf != NULL);
+	assert(max >= 0);
+	assert(fmt != NULL);
+	assert(dir != NULL);
+	assert(name != NULL);
+
+	while (*fmt && max > 0) {
+		if (*fmt == '%') {
+			switch (*++fmt) {
+				case 'F':
+					strncpy(buf, name, max);
+					l = strlen(name);
+					buf += l, max -= l;
+					break;
+
+				case 'D':
+					strncpy(buf, dir, max);
+					l = strlen(dir);
+					buf += l, max -= l;
+					break;
+
+				case 'B':
+					snprintf(scratch, FILENAME_MAX * 2,
+					    "%s/%s", dir, name);
+					cp = &scratch[strlen(scratch) - 1];
+					while (cp != scratch && *cp != '/')
+						--cp;
+					*cp = '\0';
+					strncpy(buf, scratch, max);
+					l = strlen(scratch);
+					buf += l, max -= l;
+					break;
+
+				case 'f':
+					snprintf(scratch, FILENAME_MAX * 2,
+					    "%s/%s", dir, name);
+					cp = &scratch[strlen(scratch) - 1];
+					while (cp != scratch && *(cp - 1) != '/')
+						--cp;
+					strncpy(buf, cp, max);
+					l = strlen(cp);
+					buf += l, max -= l;
+					break;
+
+				default:
+					*buf++ = *fmt;
+					--max;
+					break;
+			}
+			++fmt;
+		} else {
+			*buf++ = *fmt++;
+			--max;
+		}
+	}
+	*buf = '\0';
+}
+
+/**
  * @}
  */

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-07 02:18:27 UTC (rev 85)
+++ trunk/src/pkg_freebsd.c	2006-04-09 23:23:55 UTC (rev 86)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005, Andrew Turner, All rights reserved.
+ * Copyright (C) 2006, Andrew Turner, All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -27,44 +27,30 @@
  *
  */
 
+#include "pkg.h"
+#include "pkg_private.h"
+#include "pkg_freebsd.h"
+#include "pkg_freebsd_private.h"
+
 #include <sys/types.h>
 
+#include <assert.h>
 #include <archive.h>
 #include <archive_entry.h>
-#include <assert.h>
 #include <dirent.h>
 #include <err.h>
 #include <libgen.h>
 #include <stdlib.h>
 #include <string.h>
 
-#include "pkg.h"
-#include "pkg_freebsd.h"
-#include "pkg_private.h"
-#include "pkg_freebsd_private.h"
-
-struct freebsd_package {
-	struct archive	 *archive;
-	FILE		 *fd;
-
-	struct pkg_file **control;
-	struct pkg_freebsd_contents *contents;
-	char		 *origin;
-
-	/* If not null contains the next file in
-	 * the archive after the control files */
-	struct pkg_file	 *next;
-
-	struct pkg_file **all_files;
-	unsigned int	  all_files_size;
-	unsigned int	  all_files_pos;
-};
-
 /* Callbacks */
-pkg_static int			  freebsd_add_depend(struct pkg *,
-					struct pkg *);
+pkg_static const char		 *freebsd_get_version(struct pkg *);
+pkg_static const char		 *freebsd_get_origin(struct pkg *);
+#ifdef NOT_YET
+pkg_static int			  freebsd_add_depend(struct pkg *,struct pkg *);
 pkg_static int			  freebsd_add_file(struct pkg *,
 					struct pkg_file *);
+#endif
 pkg_static struct pkg_file	**freebsd_get_control_files(struct pkg *);
 pkg_static struct pkg_file	 *freebsd_get_control_file(struct pkg *,
 					const char *);
@@ -72,26 +58,33 @@
 pkg_static struct pkg		**freebsd_get_deps(struct pkg *);
 pkg_static int			  freebsd_free(struct pkg *);
 
-pkg_static const char		 *freebsd_get_version(struct pkg *);
-pkg_static const char		 *freebsd_get_origin(struct pkg *);
-
 /* Internal functions */
-pkg_static struct pkg_file			**freebsd_open_control_files(const char *);
-pkg_static struct freebsd_package	*freebsd_get_package(FILE *,
-					struct pkg_file **);
-pkg_static struct pkg_file		*freebsd_get_next_entry(struct archive *);
-pkg_static char 			*freebsd_get_pkg_name(const char *);
-pkg_static int			 freebsd_free_package(struct freebsd_package *);
+pkg_static struct freebsd_package *freebsd_package_new(void);
+pkg_static int			  freebsd_open_control_files(
+					struct freebsd_package *);
+pkg_static struct pkg_file	 *freebsd_get_next_entry(struct archive *);
+pkg_static int			  freebsd_parse_contents(
+					struct freebsd_package *);
 
-#define FREE_CONTENTS(c) \
-	{ \
-		int i; \
-		for (i=0; c[i] != NULL; i++) { \
-			pkg_file_free(c[i]); \
-		} \
-		free(c); \
-	}
+typedef enum {
+	fpkg_unknown,
+	fpkg_from_file,
+	fpkg_from_installed,
+	fpkg_from_empty
+} freebsd_type;
 
+struct freebsd_package {
+	FILE *fd;
+	struct archive *archive;
+	char *db_dir;
+	const char *version;
+	const char *origin;
+	struct pkg_file **control;
+	struct pkg_freebsd_contents *contents;
+	struct pkg_file *next_file;
+	freebsd_type pkg_type;
+};
+
 /**
  * @defgroup FreebsdPackage FreeBSD Package
  * @ingroup pkg
@@ -105,48 +98,58 @@
  *
  * This creates a pkg object from a given file pointer.
  * It is able to then manipulate the package and install the it to the pkg_db.
+ * @todo Write
  * @return A new package object or NULL
  */
 struct pkg *
 pkg_new_freebsd_from_file(FILE *fd)
 {
 	struct pkg *pkg;
-	struct freebsd_package *f_pkg;
-	char *pkg_name;
-	unsigned int line;
+	struct freebsd_package *fpkg;
+	const char *pkg_name;
 
 	if (fd == NULL)
 		return NULL;
+
+	/* Create the new package data object */
+	fpkg = freebsd_package_new();
+	if (fpkg == NULL)
+		return NULL;
+
+	fpkg->fd = fd;
+	fpkg->pkg_type = fpkg_from_file;
+	fpkg->archive = archive_read_new();
+	archive_read_support_compression_bzip2(fpkg->archive);
+	archive_read_support_compression_gzip(fpkg->archive);
+	archive_read_support_format_tar(fpkg->archive);
+	archive_read_open_stream(fpkg->archive, fd, 10240);
 	
-	f_pkg = freebsd_get_package(fd, NULL);
+	/*
+	 * Get the +CONTENTS file.
+	 * We can't use the callbacks as we need the
+	 * package name to use with pkg_new
+	 */
+	freebsd_open_control_files(fpkg);
+	assert(fpkg->control != NULL);
 
-	/* Find the package name */
-	pkg_name = freebsd_get_pkg_name(pkg_file_get(f_pkg->control[0]));
+	freebsd_parse_contents(fpkg);
+	assert(fpkg->contents != NULL);
+	if (fpkg->contents->lines[1].line_type != PKG_LINE_NAME) {
+		/** @todo cleanup */
+		return NULL;
+	}
 
+	pkg_name = fpkg->contents->lines[1].data;
 	pkg = pkg_new(pkg_name, freebsd_get_control_files,
 	    freebsd_get_control_file, freebsd_get_deps, freebsd_free);
-	free(pkg_name);
-
-	if (pkg == NULL)
+	if (pkg == NULL) {
+		/** @todo cleanup */
 		return NULL;
-	pkg_add_callbacks_install(pkg, freebsd_get_next_file);
+	}
 	pkg_add_callbacks_data(pkg, freebsd_get_version, freebsd_get_origin);
+	pkg_add_callbacks_install(pkg, freebsd_get_next_file);
+	pkg->data = fpkg;
 
-	pkg->data = f_pkg;
-	
-	assert(f_pkg->contents != NULL);
-	for (line = 0; line < f_pkg->contents->line_count; line++) {
-		if (f_pkg->contents->lines[line].line_type == PKG_LINE_COMMENT)
-		    {
-			if (strncmp("ORIGIN:",
-			    f_pkg->contents->lines[line].data, 7) == 0) {
-				f_pkg->origin = strdup(
-				    f_pkg->contents->lines[line].data + 7);
-				break;
-			}
-		}
-	}
-
 	return pkg;
 }
 
@@ -156,6 +159,7 @@
  * @param pkg_db_dir The directory in the database the package is registered in
  * @todo Make this work through a pkg_db callback
  * @todo Remove the need for pkg_db_dir by using a struct pkg_repo
+ * @todo move the freebsd_package creation to an internal function
  *
  * This creates a package object from an installed package.
  * It can be used to retrieve information from the pkg_db and deintall
@@ -166,49 +170,28 @@
 pkg_new_freebsd_installed(const char *pkg_name, const char *pkg_db_dir)
 {
 	struct pkg *pkg;
-	struct freebsd_package *f_pkg;
-	struct pkg_file **control;
-	unsigned int line;
+	struct freebsd_package *fpkg;
 
-
-	if (!pkg_name || ! pkg_db_dir)
-		return NULL;
-
-	/*
-	 * This section until the closedir takes too long in pkg_info.
-	 * It needs to be optimised to just read the required data
-	 */
-	control = freebsd_open_control_files(pkg_db_dir);
-
-	/* Only the get_deps and free callbacks will work */
 	pkg = pkg_new(pkg_name, freebsd_get_control_files,
-	    freebsd_get_control_file, freebsd_get_deps, freebsd_free);
-	if (pkg == NULL) {
-		FREE_CONTENTS(control);
+	    freebsd_get_control_file, NULL, freebsd_free);
+	if (pkg == NULL)
 		return NULL;
-	}
 	pkg_add_callbacks_data(pkg, freebsd_get_version, freebsd_get_origin);
 
-	f_pkg = freebsd_get_package(NULL, control);
-	if (f_pkg == NULL) {
+	fpkg = freebsd_package_new();
+	if (fpkg == NULL) {
 		pkg_free(pkg);
 		return NULL;
 	}
-	pkg->data = f_pkg;
+	pkg->data = fpkg;
 
-	assert(f_pkg->contents != NULL);
-	for (line = 0; line < f_pkg->contents->line_count; line++) {
-		if (f_pkg->contents->lines[line].line_type == PKG_LINE_COMMENT)
-		    {
-			if (strncmp("ORIGIN:",
-			    f_pkg->contents->lines[line].data, 7) == 0) {
-				f_pkg->origin = strdup(
-				    f_pkg->contents->lines[line].data + 7);
-				break;
-			}
-		}
-	}
+	fpkg->pkg_type = fpkg_from_installed;
 
+	fpkg->db_dir = strdup(pkg_db_dir);
+	if (fpkg->db_dir == NULL) {
+		pkg_free(pkg);
+		return NULL;
+	}
 	return pkg;
 }
 
@@ -218,64 +201,26 @@
  *
  * This creates an empty FreeBSD Package.
  * It can then have files added to it, eg. in pkg_create(1)
+ * @todo Write
  * @return A package object or NULL
  */
 struct pkg *
-pkg_new_freebsd_empty(const char *pkg_name)
+pkg_new_freebsd_empty(const char *pkg_name __unused)
 {
-	struct pkg *pkg;
-	struct freebsd_package *f_pkg;
-
-	if (pkg_name == NULL)
-		return NULL;
-
-	pkg = pkg_new(pkg_name, NULL, NULL, NULL, freebsd_free);
-	if (pkg == NULL)
-		return NULL;
-	pkg_add_callbacks_empty(pkg, freebsd_add_depend, freebsd_add_file);
-
-	f_pkg = freebsd_get_package(NULL, NULL);
-	pkg->data = f_pkg;
-	if (f_pkg == NULL) {
-		pkg_free(pkg);
-		return NULL;
-	}
-	f_pkg->all_files_size = sizeof(struct pkg_file *);
-	f_pkg->all_files_pos = 0;
-	f_pkg->all_files = malloc(f_pkg->all_files_size);
-	if (f_pkg->all_files == NULL) {
-		pkg_free(pkg);
-		return NULL;
-	}
-	f_pkg->all_files[0] = NULL;
-
-	/* Setup the +CONTENTS file */
-	assert(f_pkg->contents != NULL);
-	pkg_freebsd_contents_add_line(f_pkg->contents, PKG_LINE_COMMENT,
-	    "PKG_FORMAT_REVISION:1.1");
-	pkg_freebsd_contents_add_line(f_pkg->contents, PKG_LINE_NAME, pkg_name);
-
-	return pkg;
+	assert(0);
+	return NULL;
 }
 
 /**
  * @brief Gets the contents struct from a package
- * @todo Remove the need for this function to be exported
+ * @todo Write
  * @return The contents struct
  */
 struct pkg_freebsd_contents *
-pkg_freebsd_get_contents(struct pkg *pkg)
+pkg_freebsd_get_contents(struct pkg *pkg __unused)
 {
-	struct freebsd_package *f_pkg;
-	if (pkg == NULL)
-		return NULL;
-
-	f_pkg = (struct freebsd_package *)pkg->data;
-	assert(f_pkg != NULL);
-
-	/* Load the +CONTENTS file if it is NULL */
-	assert(f_pkg->contents != NULL);
-	return f_pkg->contents;
+	assert(0);
+	return NULL;
 }
 
 /**
@@ -297,35 +242,40 @@
 /**
  * @brief Callback for pkg_get_version()
  *
+ * @todo Do proper checks of line 0
  * @return A string containing the package version. Do not Free.
  */
 static const char *
 freebsd_get_version(struct pkg *pkg)
 {
-	struct freebsd_package *f_pkg;
+	struct freebsd_package *fpkg;
 	char *s;
 
 	assert(pkg != NULL);
-	assert(pkg->data != NULL);
 
-	f_pkg = pkg->data;
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type != fpkg_unknown);
+	assert(fpkg->pkg_type != fpkg_from_empty);
 
-	/* Check the package struct is correct
-	 * If any fail it means there is a bug in the library
-	 */
-	assert(f_pkg->contents != NULL);
-	assert(f_pkg->contents->lines != NULL);
-	assert(f_pkg->contents->lines[0].data != NULL);
-	assert(f_pkg->contents->lines[0].line_type == PKG_LINE_COMMENT);
-	assert(strcmp("PKG_FORMAT_REVISION:1.1", f_pkg->contents->lines[0].data) == 0);
-	s = strchr(f_pkg->contents->lines[0].data, ':');
-	if (s == NULL)
-		return NULL;
-	s++;
-	if (s[0] == '\0')
-		return NULL;
-
-	return s;
+	if (fpkg->version == NULL) {
+		freebsd_parse_contents(fpkg);
+		assert(fpkg->contents != NULL);
+		assert(fpkg->contents->lines != NULL);
+		/** @todo Make a +CONTENTS structure check */
+		assert(fpkg->contents->lines[0].data != NULL);
+		assert(fpkg->contents->lines[0].line_type == PKG_LINE_COMMENT);
+		assert(strcmp("PKG_FORMAT_REVISION:1.1", fpkg->contents->lines[0].data) == 0);
+		s = strchr(fpkg->contents->lines[0].data, ':');
+		if (s == NULL)
+			return NULL;
+		s++;
+		if (s[0] == '\0')
+			return NULL;
+		fpkg->version = s;
+	}
+	
+	return fpkg->version;
 }
 
 /**
@@ -336,15 +286,43 @@
 static const char *
 freebsd_get_origin(struct pkg *pkg)
 {
-	struct freebsd_package *f_pkg;
+	struct freebsd_package *fpkg;
 
 	assert(pkg != NULL);
-	assert(pkg->data != NULL);
 
-	f_pkg = pkg->data;
-	return f_pkg->origin;
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type != fpkg_unknown);
+	assert(fpkg->pkg_type != fpkg_from_file);
+	assert(fpkg->pkg_type != fpkg_from_empty);
+
+	/* Find the origin line and cache it */
+	if (fpkg->origin == NULL) {
+		unsigned int line;
+
+		/* Load the contents file */
+		freebsd_parse_contents(fpkg);
+		assert(fpkg->contents != NULL);
+		assert(fpkg->contents->lines != NULL);
+
+		/* Find the line with the origin */
+		for (line = 0; line < fpkg->contents->line_count; line++) {
+			if (fpkg->contents->lines[line].line_type ==
+			    PKG_LINE_COMMENT)
+			    {
+				if (strncmp("ORIGIN:",
+				    fpkg->contents->lines[line].data, 7) == 0) {
+					fpkg->origin =
+					    fpkg->contents->lines[line].data +7;
+					break;
+				}
+			}
+		}
+	}
+	return fpkg->origin;
 }
 
+#ifdef NOT_YET
 /**
  * @brief Callback for pkg_add_dependency()
  * @todo write
@@ -353,38 +331,22 @@
 static int
 freebsd_add_depend(struct pkg *pkg __unused, struct pkg *depend __unused)
 {
+	assert(0);
 	return -1;
 }
 
 /**
  * @brief Callback for pkg_add_file()
- * @todo rewrite to work
- * @return 0 on success or -1 on error
+ * @todo Write
+ * @return -1
  */
 static int
-freebsd_add_file(struct pkg *pkg, struct pkg_file *file)
+freebsd_add_file(struct pkg *pkg __unused, struct pkg_file *file __unused)
 {
-	struct freebsd_package *f_pkg;
-
-	assert(pkg != NULL);
-	assert(file != NULL);
-	assert(pkg->data != NULL);
-
-	f_pkg = pkg->data;
-
-	assert(f_pkg->all_files != NULL);
-
-	f_pkg->all_files_size += sizeof(struct pkg_file *);
-	f_pkg->all_files = realloc(f_pkg->all_files, f_pkg->all_files_size);
-	f_pkg->all_files[f_pkg->all_files_pos] = file;
-	f_pkg->all_files_pos++;
-	f_pkg->all_files[f_pkg->all_files_pos] = NULL;
-
-	assert(f_pkg->contents != NULL);
-	pkg_freebsd_contents_add_file(f_pkg->contents, file);
-	
-	return 0;
+	assert(0);
+	return -1;
 }
+#endif
 
 /**
  * @brief Callback for pkg_get_control_files()
@@ -393,15 +355,18 @@
 static struct pkg_file **
 freebsd_get_control_files(struct pkg *pkg)
 {
-	struct freebsd_package *f_pkg;
-
+	struct freebsd_package *fpkg;
 	assert(pkg != NULL);
 
-	f_pkg = pkg->data;
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type != fpkg_unknown);
+	assert(fpkg->pkg_type != fpkg_from_empty);
 
-	assert(f_pkg != NULL);
+	freebsd_open_control_files(fpkg);
 
-	return f_pkg->control;
+	assert(fpkg->control != NULL);
+	return fpkg->control;
 }
 
 /**
@@ -409,87 +374,93 @@
  * @return The named pkg_file or NULL
  */
 static struct pkg_file *
-freebsd_get_control_file(struct pkg *pkg, const char *file)
+freebsd_get_control_file(struct pkg *pkg, const char *filename)
 {
-	struct freebsd_package *f_pkg;
+	struct freebsd_package *fpkg;
 	unsigned int pos;
-
 	assert(pkg != NULL);
-	assert(file != NULL);
 
-	f_pkg = pkg->data;
-	assert(f_pkg != NULL);
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type != fpkg_unknown);
+	assert(fpkg->pkg_type != fpkg_from_empty);
 
-	for (pos = 0; f_pkg->control[pos] != NULL; pos++)
-		if (strcmp(basename(f_pkg->control[pos]->filename), file) == 0)
-			return f_pkg->control[pos];
+	freebsd_open_control_files(fpkg);
+	if (fpkg->control == NULL)
+		return NULL;
 
+	for (pos = 0; fpkg->control[pos] != NULL; pos++)
+		if (strcmp(basename(fpkg->control[pos]->filename), filename)==0)
+			return fpkg->control[pos];
 	return NULL;
 }
 
 /**
  * @brief Callback for pkg_get_next_file()
+ * @todo Write
  * @return The next non-control pkg_file or NULL
  */
 static struct pkg_file *
 freebsd_get_next_file(struct pkg *pkg)
 {
-	struct freebsd_package *f_pkg;
-
+	struct freebsd_package *fpkg;
 	assert(pkg != NULL);
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type == fpkg_from_file);
 
-	f_pkg = pkg->data;
-	assert(f_pkg != NULL);
-	assert(f_pkg->archive != NULL);
-
-	if (f_pkg->next) {
-		struct pkg_file *ret;
-
-		ret = f_pkg->next;
-		f_pkg->next = NULL;
-
-		return ret;
+	if (fpkg->next_file) {
+		struct pkg_file *pkg_file = fpkg->next_file;
+		fpkg->next_file = NULL;
+		return pkg_file;
 	}
-
-	return freebsd_get_next_entry(f_pkg->archive);
+	return freebsd_get_next_entry(fpkg->archive);
 }
 
 /**
  * @brief Callback for pkg_get_dependencies()
+ * @todo Write
  * @return An array of empty package objects, or NULL
  */
 static struct pkg **
 freebsd_get_deps(struct pkg *pkg)
 {
-	unsigned int line;
-	struct pkg_freebsd_contents *contents;
+	struct freebsd_package *fpkg;
 	struct pkg **pkgs;
 	unsigned int pkg_count;
 	size_t pkg_size;
+	unsigned int line;
 
 	assert(pkg != NULL);
-	assert(pkg->data != NULL);
 
-	/* If this is null there was an error that should have been checked */
-	contents = ((struct freebsd_package *)pkg->data)->contents;
-	assert(contents != NULL);
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type != fpkg_unknown);
+	assert(fpkg->pkg_type != fpkg_from_installed);
+	assert(fpkg->pkg_type != fpkg_from_empty);
 
+	freebsd_open_control_files(fpkg);
+	assert(fpkg->control != NULL);
+
+	assert(strcmp("+CONTENTS", pkg_file_get_name(fpkg->control[0])) == 0);
+
 	pkg_count = 0;
 	pkg_size = sizeof(struct pkg *);
 	pkgs = malloc(pkg_size);
-	if (!pkgs)
+	if (pkgs == NULL)
 		return NULL;
-	pkgs[0] = NULL;
-	for (line = 0; line < contents->line_count; line++) {
-		if (contents->lines[line].line_type == PKG_LINE_PKGDEP) {
+
+	for (line = 0; line < fpkg->contents->line_count; line++) {
+		if (fpkg->contents->lines[line].line_type == PKG_LINE_PKGDEP) {
 			pkg_size += sizeof(struct pkg *);
 			pkgs = realloc(pkgs, pkg_size);
 			pkgs[pkg_count] = pkg_new_empty
-			    (contents->lines[line].data);
+			    (fpkg->contents->lines[line].data);
 			pkg_count++;
 			pkgs[pkg_count] = NULL;
 		}
 	}
+		
 	return pkgs;
 }
 
@@ -500,11 +471,31 @@
 static int
 freebsd_free(struct pkg *pkg)
 {
+	struct freebsd_package *fpkg;
 	assert(pkg != NULL);
 
-	if (pkg->data)
-		freebsd_free_package(pkg->data);
+	fpkg = pkg->data;
+	if (fpkg) {
+		if (fpkg->db_dir != NULL)
+			free(fpkg->db_dir);
 
+		if (fpkg->next_file != NULL)
+			pkg_file_free(fpkg->next_file);
+
+		if (fpkg->control != NULL) {
+			int cur;
+
+			for (cur = 0; fpkg->control[cur] != NULL; cur++) {
+				pkg_file_free(fpkg->control[cur]);
+			}
+			free(fpkg->control);
+		}
+		if (fpkg->archive != NULL)
+			archive_read_finish(fpkg->archive);
+
+		free(fpkg);
+	}
+
 	return 0;
 }
 
@@ -525,173 +516,132 @@
  * @{
  */
 
+
+/* Internal functions */
+
 /**
- * @brief Opens all the control files in a directory dir
- * @return An array of files or NULL
+ * @brief Creates an empty struct freebsd_package
+ * @return A new creebsd_package object or NULL
  */
-static struct pkg_file **
-freebsd_open_control_files(const char *pkg_db_dir)
+static struct freebsd_package *
+freebsd_package_new()
 {
-	struct pkg_file **control;
-	unsigned int control_size, control_count;
-	DIR *d;
-	struct dirent *de;
-	
+	struct freebsd_package *fpkg;
 
-	d = opendir(pkg_db_dir);
-	if (d == NULL)
+	fpkg = malloc(sizeof(struct freebsd_package));
+	if (fpkg == NULL) {
 		return NULL;
-
-	/* Load all the + files into control */
-	control_size = sizeof(struct pkg_file **);
-	control = malloc(control_size);
-	control[0] = NULL;
-	control_count = 0;
-	while ((de = readdir(d)) != NULL) {
-		char *file;
-	
-		if (de->d_name[0] == '.') {
-			continue;
-		} else if (de->d_type != DT_REG) {
-			closedir(d);
-			FREE_CONTENTS(control);
-			return NULL;
-		} else if (de->d_name[0] != '+') {
-			/* All files must begin with + */
-			closedir(d);
-			FREE_CONTENTS(control);
-			return NULL;
-		}
-		asprintf(&file, "%s/%s", pkg_db_dir, de->d_name);
-		if (!file) {
-			closedir(d);
-			FREE_CONTENTS(control);
-			return NULL;
-		}
-		control_size += sizeof(struct pkg_file **);
-		control = realloc(control, control_size);
-		control[control_count] = pkg_file_new(file);
-		control_count++;
-		control[control_count] = NULL;
-		free(file);
 	}
-	closedir(d);
 
-	return control;
+	fpkg->fd = NULL;
+	fpkg->archive = NULL;
+	fpkg->db_dir = NULL;
+	fpkg->control = NULL;
+	fpkg->contents = NULL;
+	fpkg->origin = NULL;
+	fpkg->version = NULL;
+	fpkg->next_file = NULL;
+	fpkg->pkg_type = fpkg_unknown;
+
+	return fpkg;
 }
 
+#define FREE_CONTENTS(c) \
+	{ \
+		int i; \
+		for (i=0; c[i] != NULL; i++) { \
+			pkg_file_free(c[i]); \
+		} \
+		free(c); \
+	}
+
 /**
- * @brief Retrieves a pointer to be placed into the data of the Package object
- *
- * @return A newley created freebsd_package or NULL
+ * @brief Opens all the control files for a package
+ * @todo Make it add the files to fpkg->control
+ * @return An array of files or NULL
  */
-static struct freebsd_package *
-freebsd_get_package(FILE *fd, struct pkg_file **control)
+int
+freebsd_open_control_files(struct freebsd_package *fpkg)
 {
-	struct freebsd_package *f_pkg;
-	struct pkg_file *file;
-	size_t control_size;
-	unsigned int control_pos;
+	unsigned int control_size, control_count;
+	struct pkg_file *pkg_file;
 
-	f_pkg = malloc(sizeof(struct freebsd_package));
-	if (!f_pkg) {
-		return NULL;
+/** @todo Check the return of realloc */
+#define addFile(pkg_file) \
+	control_size += sizeof(struct pkg_file **); \
+	fpkg->control = realloc(fpkg->control, control_size); \
+	fpkg->control[control_count] = pkg_file; \
+	control_count++; \
+	fpkg->control[control_count] = NULL;
+	
+	assert(fpkg != NULL);
+
+	/* Don't attempt to get the control files again */
+	if (fpkg->control != NULL)
+		return 0;
+
+	if (fpkg->pkg_type != fpkg_from_installed &&
+	    fpkg->pkg_type != fpkg_from_file) {
+		assert(0);
+		return -1;
 	}
 
-	/* Init the struct */
-	f_pkg->archive = NULL;
-	f_pkg->next = NULL;
-	f_pkg->all_files = NULL;
-	f_pkg->all_files_size = 0;
-	f_pkg->all_files_pos = 0;
-	f_pkg->control = control;
-	f_pkg->contents = NULL;
-	f_pkg->origin = NULL;
-	f_pkg->fd = fd;
+	/* Setup the store to hold all the files */
+	control_size = sizeof(struct pkg_file **);
+	fpkg->control = malloc(control_size);
+	fpkg->control[0] = NULL;
+	control_count = 0;
+	
+	if (fpkg->pkg_type == fpkg_from_installed) {
+		DIR *d;
+		struct dirent *de;
+		assert(fpkg->db_dir != NULL);
 
-	if (control != NULL) {
-		unsigned int pos;
-		char *ptr;
+		d = opendir(fpkg->db_dir);
+		if (d == NULL)
+			return -1;
 
-		/* Find the +CONTENTS file */
-		for (pos = 0; control[pos] != NULL; pos++) {
-			ptr = basename(control[pos]->filename);
-			if (!strcmp(ptr, "+CONTENTS")) {
-				break;
+		/* Load all the + files into control */
+		while ((de = readdir(d)) != NULL) {
+			char *file;
+	
+			if (de->d_name[0] == '.') {
+				continue;
+			} else if (de->d_type != DT_REG) {
+				closedir(d);
+				FREE_CONTENTS(fpkg->control);
+				return -1;
+			} else if (de->d_name[0] != '+') {
+				/* All files must begin with + */
+				closedir(d);
+				FREE_CONTENTS(fpkg->control);
+				return -1;
 			}
+			asprintf(&file, "%s/%s", fpkg->db_dir, de->d_name);
+			if (!file) {
+				closedir(d);
+				FREE_CONTENTS(fpkg->control);
+				return -1;
+			}
+			pkg_file = pkg_file_new(file);
+			addFile(pkg_file);
+			free(file);
 		}
-		if (control[pos] == NULL) {
-			free(f_pkg);
-			return NULL;
-		}
+		closedir(d);
 
-		f_pkg->contents = pkg_freebsd_contents_new(
-		    pkg_file_get(control[pos]));
-	} else if (fd != NULL) {
-		/*
-		 * We only need to read from gzip and bzip2 as they
-		 * are the only posible file types for FreeBSD packages
-		 */
-		f_pkg->archive = archive_read_new();
-		if (!f_pkg->archive) {
-			freebsd_free_package(f_pkg);
-			return NULL;
+		return 0;
+	} else if (fpkg->pkg_type == fpkg_from_file) {
+		assert(fpkg->archive != NULL);
+		pkg_file = freebsd_get_next_entry(fpkg->archive);
+		while (pkg_file_get_name(pkg_file)[0] == '+') {
+			addFile(pkg_file);
+			pkg_file = freebsd_get_next_entry(fpkg->archive);
 		}
-		archive_read_support_compression_bzip2(f_pkg->archive);
-		archive_read_support_compression_gzip(f_pkg->archive);
-		archive_read_support_format_tar(f_pkg->archive);
-
-		if (archive_read_open_stream(f_pkg->archive, fd, 10240)
-		    != ARCHIVE_OK) {
-			freebsd_free_package(f_pkg);
-			return NULL;
-		}
-
-		/* Read the first file and check it has the correct name */
-		file = freebsd_get_next_entry(f_pkg->archive);
-
-		if (!file) {
-			freebsd_free_package(f_pkg);
-			return NULL;
-		} else if (strcmp(file->filename, "+CONTENTS")) {
-			/* Package error */
-			pkg_file_free(file);
-			freebsd_free_package(f_pkg);
-			return NULL;
-		}
-		/*
-		 * Set the control files array to be big enough for
-		 * the +CONTENTS file and a null terminator
-		 */
-		f_pkg->contents = pkg_freebsd_contents_new(pkg_file_get(file));
-
-		control_size = sizeof(struct pkg_file *) * 2;
-		f_pkg->control = malloc(control_size);
-		f_pkg->control[0] = file;
-		f_pkg->control[1] = NULL;
-		control_pos = 1;
-
-		assert(f_pkg->archive != NULL);
-		/* Add all the control files to the control array */
-		while (1) {
-			file = freebsd_get_next_entry(f_pkg->archive);
-			if (file == NULL) {
-				break;
-			} else if (file->filename[0] != '+') {
-				f_pkg->next = file;
-				break;
-			} else {
-				control_size += sizeof(struct pkg_file *);
-				f_pkg->control = realloc(f_pkg->control,
-				    control_size);
-				f_pkg->control[control_pos] = file;
-				control_pos++;
-				f_pkg->control[control_pos] = NULL;
-			}
-		}
+		fpkg->next_file = pkg_file;
+		return 0;
 	}
-
-	return f_pkg;
+	assert(0);
+	return -1;
 }
 
 /**
@@ -743,178 +693,29 @@
 }
 
 /**
- * @brief Retrieves the package name from a +CONTENTS file
- * @param buffer A NULL terminated string containing the +CONTENTS file
- * @return The name of the package the file is from
+ * @brief Parses the packages +CONTENTS file
+ * @return 0 on success, or -1 on error
  */
-static char *
-freebsd_get_pkg_name(const char *buffer)
-{
-	unsigned int len;
-	char *pkg_name, *str, *ptr;
-
-	assert(buffer != NULL);
-
-	/* Find the character after the first space on the second line */
-	str = strchr(buffer, '\n');
-	if (!str) {
-		return NULL;
-	}
-	str = strchr((const char *)str, ' ');
-	if (!str) {
-		return NULL;
-	}
-	str++;
-	if (str[0] == '\0') {
-		return NULL;
-	}
-
-	/* Copy the rest of the line to pkg_name */
-	ptr = strchr((const char *)str, '\n');
-	if (!ptr) {
-		return NULL;
-	}
-
-	len = ptr-str;
-	pkg_name = malloc(len+1);
-	if (!pkg_name) {
-		return NULL;
-	}
-
-	strlcpy(pkg_name, str, len+1);
-
-	return pkg_name;
-}
-
-/**
- * @brief Function to free the internal package data struct
- * @return 0
- */
 static int
-freebsd_free_package(struct freebsd_package *f_pkg)
+freebsd_parse_contents(struct freebsd_package *fpkg)
 {
-	unsigned int pos;
+	struct pkg_file *contents_file;
 	
-	assert(f_pkg != NULL);
+	assert(fpkg != NULL);
 
-	if (f_pkg->archive) {
-		archive_read_finish(f_pkg->archive);
-		f_pkg->archive = NULL;
-	}
+	if (fpkg->contents != NULL)
+		return -1;
 
-	if (f_pkg->fd)
-		fclose(f_pkg->fd);
+	freebsd_open_control_files(fpkg);
 
-	f_pkg->fd = NULL;
-
-	if (f_pkg->control) {
-		for (pos = 0; f_pkg->control[pos] != NULL; pos++)
-			pkg_file_free(f_pkg->control[pos]);
-		free(f_pkg->control);
-		f_pkg->control = NULL;
-	}
-
-	if (f_pkg->next)
-		pkg_file_free(f_pkg->next);
-	pkg_freebsd_contents_free(f_pkg->contents);
-
-	if (f_pkg->all_files) {
-		for (pos = 0; f_pkg->all_files[pos] != NULL; pos++)
-			pkg_file_free(f_pkg->all_files[pos]);
-
-		free(f_pkg->all_files);
-	}
-
-	if (f_pkg->origin)
-		free(f_pkg->origin);
-	
-	free(f_pkg);
-
+	contents_file = fpkg->control[0];
+	assert(strcmp("+CONTENTS", pkg_file_get_name(fpkg->control[0])) == 0);
+	if (contents_file == NULL)
+		return -1;
+	fpkg->contents = pkg_freebsd_contents_new(pkg_file_get(contents_file));
 	return 0;
 }
 
 /**
- * @brief Creates a string containing the command to run using printf
- * like substitutions
- *
- * @verbatim
- * Using fmt, replace all instances of:
- *
- * %F   With the parameter "name"
- * %D   With the parameter "dir"
- * %B   Return the directory part ("base") of %D/%F
- * %f   Return the filename part of %D/%F
- * @endverbatim
- *
- * @bug Does not check for overflow - caution!
- * @todo Move to the correct file
- */
-void
-freebsd_format_cmd(char *buf, int max, const char *fmt, const char *dir,
-	const char *name)
-{
-	char *cp, scratch[FILENAME_MAX * 2];
-	int l;
-
-	assert(buf != NULL);
-	assert(max >= 0);
-	assert(fmt != NULL);
-	assert(dir != NULL);
-	assert(name != NULL);
-
-	while (*fmt && max > 0) {
-		if (*fmt == '%') {
-			switch (*++fmt) {
-				case 'F':
-					strncpy(buf, name, max);
-					l = strlen(name);
-					buf += l, max -= l;
-					break;
-
-				case 'D':
-					strncpy(buf, dir, max);
-					l = strlen(dir);
-					buf += l, max -= l;
-					break;
-
-				case 'B':
-					snprintf(scratch, FILENAME_MAX * 2,
-					    "%s/%s", dir, name);
-					cp = &scratch[strlen(scratch) - 1];
-					while (cp != scratch && *cp != '/')
-						--cp;
-					*cp = '\0';
-					strncpy(buf, scratch, max);
-					l = strlen(scratch);
-					buf += l, max -= l;
-					break;
-
-				case 'f':
-					snprintf(scratch, FILENAME_MAX * 2,
-					    "%s/%s", dir, name);
-					cp = &scratch[strlen(scratch) - 1];
-					while (cp != scratch && *(cp - 1) != '/')
-						--cp;
-					strncpy(buf, cp, max);
-					l = strlen(cp);
-					buf += l, max -= l;
-					break;
-
-				default:
-					*buf++ = *fmt;
-					--max;
-					break;
-			}
-			++fmt;
-		} else {
-			*buf++ = *fmt++;
-			--max;
-		}
-	}
-	*buf = '\0';
-}
-
-/**
  * @}
  */
-

Modified: trunk/src/pkg_freebsd_private.h
===================================================================
--- trunk/src/pkg_freebsd_private.h	2006-04-07 02:18:27 UTC (rev 85)
+++ trunk/src/pkg_freebsd_private.h	2006-04-09 23:23:55 UTC (rev 86)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005, Andrew Turner, All rights reserved.
+ * Copyright (C) 2005, 2006 Andrew Turner, All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -37,8 +37,4 @@
 	struct pkg_freebsd_contents_line *lines;
 };
 
-/* Formats a string to be executed */
-void	freebsd_format_cmd(char *, int, const char *, const char *,
-		const char *);
-
 #endif /* __LIBPKG_PKG_FREEBSD_PRIVATE_H__ */



From zxombie at berlios.de  Mon Apr 10 09:13:49 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Mon, 10 Apr 2006 09:13:49 +0200
Subject: [Libpkg-svn] r87 - trunk/src
Message-ID: <200604100713.k3A7Dn7t025639@sheep.berlios.de>

Author: zxombie
Date: 2006-04-10 09:13:44 +0200 (Mon, 10 Apr 2006)
New Revision: 87

Modified:
   trunk/src/pkg_freebsd.c
   trunk/src/pkg_repo_ftp.c
Log:
Correct the spelling of brief
In pkg_freebsd the first file in fpkg->control may not be the +CONTENTS. Search for the file.


Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-09 23:23:55 UTC (rev 86)
+++ trunk/src/pkg_freebsd.c	2006-04-10 07:13:44 UTC (rev 87)
@@ -293,7 +293,6 @@
 	fpkg = pkg->data;
 	assert(fpkg != NULL);
 	assert(fpkg->pkg_type != fpkg_unknown);
-	assert(fpkg->pkg_type != fpkg_from_file);
 	assert(fpkg->pkg_type != fpkg_from_empty);
 
 	/* Find the origin line and cache it */
@@ -700,6 +699,7 @@
 freebsd_parse_contents(struct freebsd_package *fpkg)
 {
 	struct pkg_file *contents_file;
+	int i;
 	
 	assert(fpkg != NULL);
 
@@ -709,7 +709,13 @@
 	freebsd_open_control_files(fpkg);
 
 	contents_file = fpkg->control[0];
-	assert(strcmp("+CONTENTS", pkg_file_get_name(fpkg->control[0])) == 0);
+	for (i = 0; fpkg->control[i] != NULL; i++) {
+		if (strcmp("+CONTENTS",
+		    basename(pkg_file_get_name(fpkg->control[i]))) == 0) {
+			contents_file = fpkg->control[i];
+			break;
+		}
+	}
 	if (contents_file == NULL)
 		return -1;
 	fpkg->contents = pkg_freebsd_contents_new(pkg_file_get(contents_file));

Modified: trunk/src/pkg_repo_ftp.c
===================================================================
--- trunk/src/pkg_repo_ftp.c	2006-04-09 23:23:55 UTC (rev 86)
+++ trunk/src/pkg_repo_ftp.c	2006-04-10 07:13:44 UTC (rev 87)
@@ -209,7 +209,7 @@
  */
 
 /**
- * @bried Retrieves a FILE pointer for a given package name
+ * @brief Retrieves a FILE pointer for a given package name
  * @return A FILE pointer to get a package with fetch(3)
  */
 static FILE *



From zxombie at berlios.de  Tue Apr 11 03:48:30 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 11 Apr 2006 03:48:30 +0200
Subject: [Libpkg-svn] r88 - trunk/src
Message-ID: <200604110148.k3B1mUjO015381@sheep.berlios.de>

Author: zxombie
Date: 2006-04-11 03:47:56 +0200 (Tue, 11 Apr 2006)
New Revision: 88

Modified:
   trunk/src/pkg_freebsd.c
Log:
Check if the package's database directory exists and is a directory before creating the pkg object
Return the correct value in freebsd_parse_contents when it has already been called
Set contents_file to NULL at the start to make thecheck after the for loop valid


Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-10 07:13:44 UTC (rev 87)
+++ trunk/src/pkg_freebsd.c	2006-04-11 01:47:56 UTC (rev 88)
@@ -171,7 +171,14 @@
 {
 	struct pkg *pkg;
 	struct freebsd_package *fpkg;
+	struct stat sb;
 
+	/* check the directory exists and is a directory */
+	if (lstat(pkg_db_dir, &sb) == -1)
+		return NULL;
+	if (!S_ISDIR(sb.st_mode))
+		return NULL;
+
 	pkg = pkg_new(pkg_name, freebsd_get_control_files,
 	    freebsd_get_control_file, NULL, freebsd_free);
 	if (pkg == NULL)
@@ -704,11 +711,11 @@
 	assert(fpkg != NULL);
 
 	if (fpkg->contents != NULL)
-		return -1;
+		return 0;
 
 	freebsd_open_control_files(fpkg);
 
-	contents_file = fpkg->control[0];
+	contents_file = NULL;
 	for (i = 0; fpkg->control[i] != NULL; i++) {
 		if (strcmp("+CONTENTS",
 		    basename(pkg_file_get_name(fpkg->control[i]))) == 0) {



From zxombie at berlios.de  Tue Apr 11 03:51:08 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 11 Apr 2006 03:51:08 +0200
Subject: [Libpkg-svn] r89 - trunk/src
Message-ID: <200604110151.k3B1p8lK016528@sheep.berlios.de>

Author: zxombie
Date: 2006-04-11 03:50:56 +0200 (Tue, 11 Apr 2006)
New Revision: 89

Modified:
   trunk/src/pkg_db.c
   trunk/src/pkg_db.h
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_db_private.h
Log:
Allow package installation to be faked. This is useful for "pkg_add -nv bla"


Modified: trunk/src/pkg_db.c
===================================================================
--- trunk/src/pkg_db.c	2006-04-11 01:47:56 UTC (rev 88)
+++ trunk/src/pkg_db.c	2006-04-11 01:50:56 UTC (rev 89)
@@ -127,7 +127,7 @@
 int
 pkg_db_install_pkg(struct pkg_db *db, struct pkg *pkg)
 {
-	return pkg_db_install_pkg_action(db, pkg, NULL);
+	return pkg_db_install_pkg_action(db, pkg, 0, NULL);
 }
 
 /**
@@ -136,10 +136,11 @@
  * @param pkg The package to install
  * @param action A callback that is used to inform the user the status
  *     of the installation
+ * @param fake If true we will only fetch the package and report what would have happened during the install
  * @return 0 if the package is installed, -1 otherwise
  */
 int
-pkg_db_install_pkg_action(struct pkg_db *db, struct pkg *pkg,
+pkg_db_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int fake,
     pkg_db_action *action)
 {
 	if (!db) {
@@ -154,7 +155,7 @@
 		return -1;
 	}
 
-	return db->pkg_install(db, pkg, action);
+	return db->pkg_install(db, pkg, fake, action);
 }
 
 /**

Modified: trunk/src/pkg_db.h
===================================================================
--- trunk/src/pkg_db.h	2006-04-11 01:47:56 UTC (rev 88)
+++ trunk/src/pkg_db.h	2006-04-11 01:50:56 UTC (rev 89)
@@ -49,7 +49,7 @@
 
 struct pkg_db	 *pkg_db_open_freebsd(const char *);
 int		  pkg_db_install_pkg(struct pkg_db *, struct pkg *);
-int		  pkg_db_install_pkg_action(struct pkg_db *, struct pkg *,
+int		  pkg_db_install_pkg_action(struct pkg_db *, struct pkg *, int,
 			pkg_db_action *);
 int		  pkg_db_is_installed(struct pkg_db *, struct pkg *);
 struct pkg	**pkg_db_get_installed(struct pkg_db *);

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-11 01:47:56 UTC (rev 88)
+++ trunk/src/pkg_db_freebsd.c	2006-04-11 01:50:56 UTC (rev 89)
@@ -63,7 +63,7 @@
 };
 
 pkg_static int		  freebsd_install_pkg_action(struct pkg_db *,
-				struct pkg *, pkg_db_action *);
+				struct pkg *, int, pkg_db_action *);
 pkg_static int		  freebsd_is_installed(struct pkg_db *, struct pkg *);
 pkg_static struct pkg	**freebsd_get_installed_match(struct pkg_db *,
 				pkg_db_match *, const void *);
@@ -73,9 +73,9 @@
 pkg_static struct pkg_file	*freebsd_build_contents(
 				struct pkg_freebsd_contents *);
 pkg_static int			 freebsd_do_cwd(struct pkg_db *, struct pkg *,
-				char *ndir);
+				char *, int);
 pkg_static int			 freebsd_check_contents(struct pkg_db *,
-				struct pkg_freebsd_contents *);
+				struct pkg_freebsd_contents *, int);
 pkg_static void			 freebsd_format_cmd(char *, int, const char *,
 				const char *, const char *);
 
@@ -115,6 +115,7 @@
  * @param db The database to install to
  * @param pkg The package to install
  * @param pkg_action A function to call when an action takes place
+ * @param fake Should we actually install the package or just report what would have happened
  * @todo Run mtree
  * @todo Register the reverse dependencies
  * @bug When the install fails part way through remove some files are left.
@@ -122,7 +123,7 @@
  * @return 0 on success, -1 on error
  */
 static int
-freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg,
+freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int fake,
     pkg_db_action *pkg_action)
 {
 	struct pkg_file	*contents_file;
@@ -164,7 +165,7 @@
 		return -1;
 	}
 
-	i = freebsd_check_contents(db, contents);
+	i = freebsd_check_contents(db, contents, fake);
 	if (i < 0) {
 		pkg_freebsd_contents_free(contents);
 		chdir(cwd);
@@ -189,25 +190,28 @@
 			break;
 		case PKG_LINE_CWD:
 			/* Change to the correct directory */
+			if (!fake) {
 			free(directory);
-			if (freebsd_do_cwd(db, pkg, contents->lines[line].data)
-			    != 0) {
+			if (freebsd_do_cwd(db, pkg, contents->lines[line].data,
+			    fake) != 0) {
 				chdir(cwd);
 				free(cwd);
 				free(prefix);
 				pkg_freebsd_contents_free(contents);
 				return -1;
 			}
+			directory = getcwd(NULL, 0);
+			}
 			if (pkg_action != NULL)
 				pkg_action(PKG_DB_PACKAGE, "CWD to %s",
 				    contents->lines[line].data);
-			directory = getcwd(NULL, 0);
 			break;
 		case PKG_LINE_EXEC: {
 			char cmd[FILENAME_MAX];
 			freebsd_format_cmd(cmd, FILENAME_MAX,
 			    contents->lines[line].data, directory, last_file);
-			pkg_exec(cmd);
+			if (!fake)
+				pkg_exec(cmd);
 			if (pkg_action != NULL)
 				pkg_action(PKG_DB_PACKAGE, "execute '%s'", cmd);
 			break;
@@ -285,15 +289,17 @@
 			}
 
 			/* Install the file */
-			ret = pkg_file_write(file);
-			if (ret != 0) {
-				chdir(cwd);
-				free(cwd);
-				free(directory);
-				free(prefix);
-				pkg_file_free(file);
-				pkg_freebsd_contents_free(contents);
-				return -1;
+			if (!fake) {
+				ret = pkg_file_write(file);
+				if (ret != 0) {
+					chdir(cwd);
+					free(cwd);
+					free(directory);
+					free(prefix);
+					pkg_file_free(file);
+					pkg_freebsd_contents_free(contents);
+					return -1;
+				}
 			}
 
 			/* Remember the name if there is an "@exec" line next */
@@ -317,15 +323,20 @@
 	}
 
 	/* Create the new contents file */
-	contents_file = freebsd_build_contents(contents);
-	pkg_file_write(contents_file);
-	pkg_file_free(contents_file);
+	if (!fake) {
+		contents_file = freebsd_build_contents(contents);
+		pkg_file_write(contents_file);
+		pkg_file_free(contents_file);
+	}
 
 	if (pkg_action != NULL)
 		pkg_action(PKG_DB_INFO, "Running mtree for %s..",
 		    pkg_get_name(pkg));
-	/* XXX Run mtree: mtree -U -f +MTREE_DIRS -d -e -p $PREFIX >/dev/null */
-	pkg_exec("mtree -U -f +MTREE_DIRS -d -e -p %s >/dev/null", prefix);
+
+	if (!fake)
+		pkg_exec("mtree -U -f +MTREE_DIRS -d -e -p %s >/dev/null",
+		    prefix);
+
 	free(prefix);
 	
 	if (pkg_action != NULL)
@@ -333,14 +344,14 @@
 		    "Attempting to record package into /var/db/pkg/%s..",
 		    pkg_get_name(pkg));
 
-	/* XXX Register the reverse dependencies */
+	/** @todo Register the reverse dependencies */
 	if (pkg_action != NULL)
 		pkg_action(PKG_DB_INFO,
-		    "Package %s registered in /var/db/pkg/%s",
+		    "Package %s registered in " DB_LOCATION "/%s",
 		    pkg_get_name(pkg), pkg_get_name(pkg));
 
 	free(directory);
-	if (last_file)
+	if (last_file != NULL)
 		free(last_file);
 	chdir(cwd);
 	free(cwd);
@@ -479,7 +490,7 @@
  * @return 0 if successful or -1 on error
  */
 static int
-freebsd_do_cwd(struct pkg_db *db, struct pkg *pkg, char *ndir) {
+freebsd_do_cwd(struct pkg_db *db, struct pkg *pkg, char *ndir, int fake) {
 	char *dir;
 
 	assert(db != NULL);
@@ -492,7 +503,13 @@
 	if (ndir[0] == '.' &&
 	    ndir[1] == '\0') {
 		assert(pkg != NULL); /* pkg is only needed to chdir to . */
-		asprintf(&dir, "%s/var/db/pkg/%s", db->db_base, pkg->pkg_name);
+
+		/* When faking it don't create the database dir */
+		if (fake)
+			return 0;
+
+		asprintf(&dir, "%s/var/db/pkg/%s", db->db_base,
+		    pkg_get_name(pkg));
 		if (!dir) {
 			return -1;
 		}
@@ -601,7 +618,8 @@
  * @return The number of lines to skip to get to the first file or -1 on error
  */
 static int
-freebsd_check_contents(struct pkg_db *db, struct pkg_freebsd_contents *contents)
+freebsd_check_contents(struct pkg_db *db, struct pkg_freebsd_contents *contents,
+		int fake)
 {
 	unsigned int i;
 	int state;
@@ -626,8 +644,8 @@
 		}
 		/* If the current line is @chdir... do it */
 		if (contents->lines[i].line_type == PKG_LINE_CWD) {
-			if (freebsd_do_cwd(db, NULL, contents->lines[i].data)
-			    != 0) {
+			if (freebsd_do_cwd(db, NULL, contents->lines[i].data,
+			    fake) != 0) {
 				return -1;
 			}
 		}

Modified: trunk/src/pkg_db_private.h
===================================================================
--- trunk/src/pkg_db_private.h	2006-04-11 01:47:56 UTC (rev 88)
+++ trunk/src/pkg_db_private.h	2006-04-11 01:50:56 UTC (rev 89)
@@ -30,7 +30,7 @@
 #ifndef __LIBPKG_PKG_DB_PRIVATE_H__
 #define __LIBPKG_PKG_DB_PRIVATE_H__
 
-typedef int	 pkg_db_install_pkg_callback(struct pkg_db *, struct pkg *,
+typedef int	 pkg_db_install_pkg_callback(struct pkg_db *, struct pkg *, int,
 			pkg_db_action *);
 typedef int 	 pkg_db_is_installed_callback(struct pkg_db *, struct pkg *);
 typedef struct pkg	 *pkg_db_get_package_callback(struct pkg_db *,



From zxombie at berlios.de  Tue Apr 11 04:07:20 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 11 Apr 2006 04:07:20 +0200
Subject: [Libpkg-svn] r90 - trunk/tools/pkg_add
Message-ID: <200604110207.k3B27KqJ022183@sheep.berlios.de>

Author: zxombie
Date: 2006-04-11 04:07:15 +0200 (Tue, 11 Apr 2006)
New Revision: 90

Modified:
   trunk/tools/pkg_add/main.c
Log:
Make add.verbosity add.flags with a single bit for each flag
Store the -f, -I, -K, -n, -R and -v arguments in add.flags
Implement -n to use the faked installation opetion of pkg_db


Modified: trunk/tools/pkg_add/main.c
===================================================================
--- trunk/tools/pkg_add/main.c	2006-04-11 01:50:56 UTC (rev 89)
+++ trunk/tools/pkg_add/main.c	2006-04-11 02:07:15 UTC (rev 90)
@@ -31,11 +31,18 @@
 #include <string.h>
 #include <unistd.h>
 
+#define verbosity_flag		(1)
+#define keep_file_flag		(1<<1)
+#define no_run_flag		(1<<2)
+#define force_flag		(1<<3)
+#define no_run_script_flag	(1<<4)
+#define no_record_install_flag	(1<<5)
+
 struct pkg_add {
 	struct pkg_db	 *db;
 	struct pkg_repo	 *repo;
 	struct pkg	**pkgs;
-	int		  verbosity;
+	int		  flags;
 	char		  chroot[PATH_MAX];
 };
 
@@ -43,8 +50,7 @@
 
 static void usage(void);
 static int pkg_add(struct pkg_add);
-static int install_package(struct pkg *, struct pkg_repo *, struct pkg_db *,
-		int);
+static int install_package(struct pkg *, struct pkg_repo *,struct pkg_db *,int);
 
 int
 main (int argc, char *argv[])
@@ -55,7 +61,7 @@
 
 	add.db = NULL;
 	add.repo = NULL;
-	add.verbosity = 0;
+	add.flags = 0;
 	add.chroot[0] = '\0';
 	while ((ch = getopt(argc, argv, options)) != -1) {
 		switch(ch) {
@@ -64,24 +70,22 @@
 			strlcpy(add.chroot, optarg, PATH_MAX);
 			break;
 		case 'f':
-			/* TODO */
-			errx(1, "Unsupported argument");
+			add.flags |= force_flag;
 			break;
 		case 'I':
-			/* TODO */
+			add.flags |= no_run_script_flag;
 			errx(1, "Unsupported argument");
 			break;
 		case 'K':
-			/* TODO */
+			/* Save the package file in . or ${PKGDIR} */
+			add.flags |= keep_file_flag;
 			errx(1, "Unsupported argument");
 			break;
 		case 'M':
 			errx(1, "Unsupported argument");
 			break;
 		case 'n':
-			/* TODO */
-			/* This dosn't seem to do anything in the base version */
-			errx(1, "Unsupported argument");
+			add.flags |= no_run_flag;
 			break;
 		case 'P':
 			errx(1, "Unsupported argument");
@@ -90,7 +94,7 @@
 			errx(1, "Unsupported argument");
 			break;
 		case 'R':
-			/* TODO */
+			add.flags |= no_record_install_flag;
 			errx(1, "Unsupported argument");
 			break;
 		case 'r':
@@ -101,10 +105,10 @@
 			errx(1, "Unsupported argument");
 			break;
 		case 't':
-			errx(1, "The -t argument is unneded as the staging area is unused");
+			errx(1, "The -t argument is unneeded as the staging area is unused");
 			break;
 		case 'v':
-			add.verbosity = 1;
+			add.flags |= verbosity_flag;
 			break;
 		case 'h':
 		case '?':
@@ -174,7 +178,7 @@
 			    pkg_get_name(add.pkgs[i]));
 			continue;
 		}
-		install_package(add.pkgs[i], add.repo, add.db, add.verbosity);
+		install_package(add.pkgs[i], add.repo, add.db, add.flags);
 	}
 	return 1;
 }
@@ -200,7 +204,8 @@
  * Recursivley install the required packages
  */
 static int
-install_package(struct pkg *pkg, struct pkg_repo *repo, struct pkg_db *db, int verbosity)
+install_package(struct pkg *pkg, struct pkg_repo *repo, struct pkg_db *db,
+		int flags)
 {
 	unsigned int i;
 	int ret;
@@ -231,18 +236,20 @@
 		deps[i] = new_pkg;
 
 		/* Install the dependency */
-		if (install_package(deps[i], repo, db, verbosity) != 0) {
+		if (install_package(deps[i], repo, db, flags) != 0 &&
+		    (flags & force_flag) != force_flag) {
 			return -1;
 		}
 	}
 	pkg_list_free(deps);
 
-	if (verbosity) {
+	if ((flags & verbosity_flag) == verbosity_flag) {
 		printf("extract: Package name is %s\n", pkg_get_name(pkg));
-		ret = pkg_db_install_pkg_action(db, pkg, pkg_action);
-	} else {
+		ret = pkg_db_install_pkg_action(db, pkg,
+		    ((flags & no_run_flag) == no_run_flag), pkg_action);
+	} else if ((flags & no_run_flag) == 0) {
 		ret = pkg_db_install_pkg(db, pkg);
 	}
-	/* XXX Ass warning if ret != 0 */
+	/* XXX Add warning if ret != 0 */
 	return ret;
 }



From zxombie at berlios.de  Tue Apr 11 05:42:16 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 11 Apr 2006 05:42:16 +0200
Subject: [Libpkg-svn] r91 - trunk/src
Message-ID: <200604110342.k3B3gGAR020579@sheep.berlios.de>

Author: zxombie
Date: 2006-04-11 05:42:12 +0200 (Tue, 11 Apr 2006)
New Revision: 91

Modified:
   trunk/src/pkg_repo_ftp.c
Log:
Update the list of ftp directories to FreeBSD HEAD


Modified: trunk/src/pkg_repo_ftp.c
===================================================================
--- trunk/src/pkg_repo_ftp.c	2006-04-11 02:07:15 UTC (rev 90)
+++ trunk/src/pkg_repo_ftp.c	2006-04-11 03:42:12 UTC (rev 91)
@@ -50,30 +50,31 @@
         int hiver;      /* Highest version number to match */
         const char *directory;  /* Directory it lives in */
 } releases[] = {
-        { 410000, 410000, "packages-4.1-release" },
-        { 420000, 420000, "packages-4.2-release" },
-        { 430000, 430000, "packages-4.3-release" },
-        { 440000, 440000, "packages-4.4-release" },
-        { 450000, 450000, "packages-4.5-release" },
-        { 460000, 460001, "packages-4.6-release" },
-        { 460002, 460099, "packages-4.6.2-release" },
-        { 470000, 470099, "packages-4.7-release" },
-        { 480000, 480099, "packages-4.8-release" },
-        { 490000, 490099, "packages-4.9-release" },
-        { 491000, 491099, "packages-4.10-release" },
-        { 492000, 492099, "packages-4.11-release" },
-        { 500000, 500099, "packages-5.0-release" },
-        { 501000, 501099, "packages-5.1-release" },
-        { 502000, 502009, "packages-5.2-release" },
-        { 502010, 502099, "packages-5.2.1-release" },
-        { 503000, 503099, "packages-5.3-release" },
-        { 504000, 504099, "packages-5.4-release" },
-        { 300000, 399000, "packages-3-stable" },
-        { 400000, 499000, "packages-4-stable" },
-        { 502100, 502128, "packages-5-current" },
-        { 503100, 599000, "packages-5-stable" },
-        { 600000, 699000, "packages-6-current" },
-        { 700000, 799000, "packages-7-current" },
+	{ 410000, 410000, "/packages-4.1-release" },
+	{ 420000, 420000, "/packages-4.2-release" },
+	{ 430000, 430000, "/packages-4.3-release" },
+	{ 440000, 440000, "/packages-4.4-release" },
+	{ 450000, 450000, "/packages-4.5-release" },
+	{ 460000, 460001, "/packages-4.6-release" },
+	{ 460002, 460099, "/packages-4.6.2-release" },
+	{ 470000, 470099, "/packages-4.7-release" },
+	{ 480000, 480099, "/packages-4.8-release" },
+	{ 490000, 490099, "/packages-4.9-release" },
+	{ 491000, 491099, "/packages-4.10-release" },
+	{ 492000, 492099, "/packages-4.11-release" },
+	{ 500000, 500099, "/packages-5.0-release" },
+	{ 501000, 501099, "/packages-5.1-release" },
+	{ 502000, 502009, "/packages-5.2-release" },
+	{ 502010, 502099, "/packages-5.2.1-release" },
+	{ 503000, 503099, "/packages-5.3-release" },
+	{ 504000, 504099, "/packages-5.4-release" },
+	{ 600000, 600099, "/packages-6.0-release" },
+	{ 300000, 399000, "/packages-3-stable" },
+	{ 400000, 499000, "/packages-4-stable" },
+	{ 502100, 502128, "/packages-5-current" },
+	{ 503100, 599000, "/packages-5-stable" },
+	{ 600100, 699000, "/packages-6-stable" },
+	{ 700000, 799000, "/packages-7-current" },
         { 0, MAX_VERSION, "packages-current" },
         { 0, 0, NULL }
 };



From zxombie at berlios.de  Wed Apr 12 12:34:38 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 12 Apr 2006 12:34:38 +0200
Subject: [Libpkg-svn] r92 - trunk/src
Message-ID: <200604121034.k3CAYcqw010677@sheep.berlios.de>

Author: zxombie
Date: 2006-04-12 12:34:22 +0200 (Wed, 12 Apr 2006)
New Revision: 92

Modified:
   trunk/src/pkg.c
   trunk/src/pkg.h
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_freebsd.c
   trunk/src/pkg_private.h
Log:
Implement execution of pre/post installation scripts


Modified: trunk/src/pkg.c
===================================================================
--- trunk/src/pkg.c	2006-04-11 03:42:12 UTC (rev 91)
+++ trunk/src/pkg.c	2006-04-12 10:34:22 UTC (rev 92)
@@ -89,6 +89,7 @@
 	pkg->pkg_add_depend = NULL;
 	pkg->pkg_add_file = NULL;
 	pkg->pkg_get_next_file = NULL;
+	pkg->pkg_run_script = NULL;
 
 	/* The data is unknown so set to NULL */	
 	pkg->data = NULL;
@@ -142,17 +143,20 @@
  * @brief Internal function to add callbacks that are used when a package is installed
  * @param pkg The package returned by pkg_new()
  * @param next_file A callback to be used by pkg_get_next_file()
+ * @param run_script A callback to be used by pkg_run_script()
  * @return 0 on success, -1 on error.
  * @return
  */
 int
 pkg_add_callbacks_install (struct pkg *pkg,
-		pkg_get_next_file_callback *next_file)
+		pkg_get_next_file_callback *next_file,
+		pkg_run_script_callback *run_script)
 {
 	if (pkg == NULL)
 		return -1;
 
 	pkg->pkg_get_next_file = next_file;
+	pkg->pkg_run_script = run_script;
 	return 0;
 }
 
@@ -328,6 +332,22 @@
 }
 
 /**
+ * @brief Runs the named script from the package
+ * @return The return value of the script, or -1
+ */
+int
+pkg_run_script(struct pkg *pkg, pkg_script script)
+{
+	if (pkg == NULL)
+			return -1;
+
+	if (pkg->pkg_run_script == NULL)
+		return -1;
+
+	return pkg->pkg_run_script(pkg, script);
+}
+
+/**
  * @brief Adds a dependency to a given package
  * @return 0 on success, -1 on error.
  */

Modified: trunk/src/pkg.h
===================================================================
--- trunk/src/pkg.h	2006-04-11 03:42:12 UTC (rev 91)
+++ trunk/src/pkg.h	2006-04-12 10:34:22 UTC (rev 92)
@@ -60,6 +60,12 @@
  */
 struct pkg;
 
+typedef enum {
+	pkg_script_noop,
+	pkg_script_pre,
+	pkg_script_post
+} pkg_script;
+
 struct pkg		 *pkg_new_empty(const char *);
 struct pkg		 *pkg_new_freebsd_from_file(FILE *);
 struct pkg		 *pkg_new_freebsd_installed(const char *, const char *);
@@ -72,6 +78,7 @@
 struct pkg_file		 *pkg_get_next_file(struct pkg *);
 const const char	 *pkg_get_origin(struct pkg *);
 const const char	 *pkg_get_version(struct pkg *);
+int			  pkg_run_script(struct pkg *, pkg_script);
 int			  pkg_add_dependency(struct pkg *, struct pkg *);
 int			  pkg_add_file(struct pkg *, struct pkg_file *);
 int			  pkg_list_free(struct pkg **);

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-11 03:42:12 UTC (rev 91)
+++ trunk/src/pkg_db_freebsd.c	2006-04-12 10:34:22 UTC (rev 92)
@@ -179,6 +179,9 @@
 	prefix = strdup(directory);
 	last_file = NULL;
 
+	/** @todo pkg_action the pre script */
+	pkg_run_script(pkg, pkg_script_pre);
+
 	/* Read through the contents file and install the package */
 	for (; line < contents->line_count; line++) {
 		switch (contents->lines[line].line_type) {
@@ -338,7 +341,10 @@
 		    prefix);
 
 	free(prefix);
-	
+
+	/** @todo pkg_action the post script */
+	pkg_run_script(pkg, pkg_script_post);
+
 	if (pkg_action != NULL)
 		pkg_action(PKG_DB_INFO,
 		    "Attempting to record package into /var/db/pkg/%s..",

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-11 03:42:12 UTC (rev 91)
+++ trunk/src/pkg_freebsd.c	2006-04-12 10:34:22 UTC (rev 92)
@@ -56,6 +56,7 @@
 					const char *);
 pkg_static struct pkg_file	 *freebsd_get_next_file(struct pkg *);
 pkg_static struct pkg		**freebsd_get_deps(struct pkg *);
+pkg_static int			  freebsd_run_script(struct pkg *, pkg_script);
 pkg_static int			  freebsd_free(struct pkg *);
 
 /* Internal functions */
@@ -147,7 +148,8 @@
 		return NULL;
 	}
 	pkg_add_callbacks_data(pkg, freebsd_get_version, freebsd_get_origin);
-	pkg_add_callbacks_install(pkg, freebsd_get_next_file);
+	pkg_add_callbacks_install(pkg, freebsd_get_next_file,
+	    freebsd_run_script);
 	pkg->data = fpkg;
 
 	return pkg;
@@ -471,6 +473,74 @@
 }
 
 /**
+ * @brief Callback for pkg_run_script()
+ * @return 0
+ */
+static int
+freebsd_run_script(struct pkg *pkg, pkg_script script)
+{
+	struct freebsd_package *fpkg;
+	struct pkg_file *script_file;
+	char arg[FILENAME_MAX];
+	char dir[FILENAME_MAX];
+	char *dir1, *cwd;
+	int ret;
+
+	assert(pkg != NULL);
+
+	fpkg = pkg->data;
+	assert(fpkg != NULL);
+	assert(fpkg->pkg_type != fpkg_unknown);
+	assert(fpkg->pkg_type != fpkg_from_installed);
+	assert(fpkg->pkg_type != fpkg_from_empty);
+
+	script_file = NULL;
+	arg[0] = '\0';
+	switch (script) {
+	case pkg_script_pre:
+		script_file = pkg_get_control_file(pkg, "+PRE-INSTALL");
+		if (script_file == NULL) {
+			script_file = pkg_get_control_file(pkg, "+INSTALL");
+			snprintf(arg, FILENAME_MAX, "PRE-INSTALL");
+		}
+		break;
+	case pkg_script_post:
+		script_file = pkg_get_control_file(pkg, "+POST-INSTALL");
+		if (script_file == NULL) {
+			script_file = pkg_get_control_file(pkg, "+INSTALL");
+			snprintf(arg, FILENAME_MAX, "POST-INSTALL");
+		}
+		break;
+	default:
+		return -1;
+	}
+	if (script_file == NULL)
+		return 0;
+
+	/** @todo make a tempdir, cd tempdir, extrace the file, execute it, cleanup tempdir */
+	/** @todo Add a lock around mkdtemp ad arc4random is not thread safe */
+	snprintf(dir, FILENAME_MAX, "/tmp/libpkg_XXXXXXX");
+	dir1 = mkdtemp(dir);
+
+	/* Change to the temp dir and back up the current dir to return here */
+	cwd = getcwd(NULL, 0);
+	chdir(dir1);
+
+	/* Extract the script */
+	pkg_file_write(script_file);
+	pkg_exec("chmod u+x %s", pkg_file_get_name(script_file));
+	chdir(cwd);
+	free(cwd);
+
+	/* Execute the script */
+	ret = pkg_exec("%s/%s %s %s", dir1, pkg_file_get_name(script_file),
+	    pkg_get_name(pkg), arg);
+
+	rmdir(dir1);
+	return ret;
+}
+
+/**
  * @brief Callback for pkg_free()
  * @return 0
  */

Modified: trunk/src/pkg_private.h
===================================================================
--- trunk/src/pkg_private.h	2006-04-11 03:42:12 UTC (rev 91)
+++ trunk/src/pkg_private.h	2006-04-12 10:34:22 UTC (rev 92)
@@ -77,8 +77,10 @@
 
 /* Callbacks used with installable packages. Used by pkg_repo */
 typedef struct pkg_file	 *pkg_get_next_file_callback(struct pkg *);
+typedef int		  pkg_run_script_callback(struct pkg *, pkg_script);
 int			  pkg_add_callbacks_install(struct pkg *,
-				pkg_get_next_file_callback *);
+				pkg_get_next_file_callback *,
+				pkg_run_script_callback *);
 
 struct pkg {
 	void	*data;
@@ -100,6 +102,7 @@
 
 	/* Callbacks used with installing packages */
 	pkg_get_next_file_callback	*pkg_get_next_file;
+	pkg_run_script_callback		*pkg_run_script;
 };
 
 int pkg_dir_build(const char *);



From zxombie at berlios.de  Fri Apr 14 00:18:52 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 14 Apr 2006 00:18:52 +0200
Subject: [Libpkg-svn] r93 - trunk/src
Message-ID: <200604132218.k3DMIqiG027422@sheep.berlios.de>

Author: zxombie
Date: 2006-04-14 00:18:51 +0200 (Fri, 14 Apr 2006)
New Revision: 93

Modified:
   trunk/src/pkg_db.c
   trunk/src/pkg_db.h
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_db_private.h
   trunk/src/pkg_freebsd.c
Log:
Allow packages to be installed without registering the installation


Modified: trunk/src/pkg_db.c
===================================================================
--- trunk/src/pkg_db.c	2006-04-12 10:34:22 UTC (rev 92)
+++ trunk/src/pkg_db.c	2006-04-13 22:18:51 UTC (rev 93)
@@ -125,22 +125,24 @@
  * @return 0 on success, -1 on error
  */
 int
-pkg_db_install_pkg(struct pkg_db *db, struct pkg *pkg)
+pkg_db_install_pkg(struct pkg_db *db, struct pkg *pkg, int reg)
 {
-	return pkg_db_install_pkg_action(db, pkg, 0, NULL);
+	return pkg_db_install_pkg_action(db, pkg, reg, 0, NULL);
 }
 
 /**
  * @brief Installs a package to the database
  * @param db The database to install to
  * @param pkg The package to install
+ * @param reg If true register the package
+ * @param fake If true we will only fetch the package and report what would
+ *     have happened during the install
  * @param action A callback that is used to inform the user the status
  *     of the installation
- * @param fake If true we will only fetch the package and report what would have happened during the install
  * @return 0 if the package is installed, -1 otherwise
  */
 int
-pkg_db_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int fake,
+pkg_db_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int reg, int fake,
     pkg_db_action *action)
 {
 	if (!db) {
@@ -155,7 +157,7 @@
 		return -1;
 	}
 
-	return db->pkg_install(db, pkg, fake, action);
+	return db->pkg_install(db, pkg, reg, fake, action);
 }
 
 /**
@@ -276,6 +278,9 @@
 int
 pkg_match_by_origin(struct pkg *pkg, const void *origin)
 {
+	if (pkg_get_origin(pkg) == NULL)
+		return -1;
+
 	return strcmp(pkg_get_origin(pkg), (const char *)origin);
 }
 

Modified: trunk/src/pkg_db.h
===================================================================
--- trunk/src/pkg_db.h	2006-04-12 10:34:22 UTC (rev 92)
+++ trunk/src/pkg_db.h	2006-04-13 22:18:51 UTC (rev 93)
@@ -48,9 +48,9 @@
 typedef		  void pkg_db_action(int, const char *, ...);
 
 struct pkg_db	 *pkg_db_open_freebsd(const char *);
-int		  pkg_db_install_pkg(struct pkg_db *, struct pkg *);
+int		  pkg_db_install_pkg(struct pkg_db *, struct pkg *, int);
 int		  pkg_db_install_pkg_action(struct pkg_db *, struct pkg *, int,
-			pkg_db_action *);
+			int, pkg_db_action *);
 int		  pkg_db_is_installed(struct pkg_db *, struct pkg *);
 struct pkg	**pkg_db_get_installed(struct pkg_db *);
 struct pkg	**pkg_db_get_installed_match(struct pkg_db *, pkg_db_match *,

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-12 10:34:22 UTC (rev 92)
+++ trunk/src/pkg_db_freebsd.c	2006-04-13 22:18:51 UTC (rev 93)
@@ -63,7 +63,7 @@
 };
 
 pkg_static int		  freebsd_install_pkg_action(struct pkg_db *,
-				struct pkg *, int, pkg_db_action *);
+				struct pkg *, int, int, pkg_db_action *);
 pkg_static int		  freebsd_is_installed(struct pkg_db *, struct pkg *);
 pkg_static struct pkg	**freebsd_get_installed_match(struct pkg_db *,
 				pkg_db_match *, const void *);
@@ -123,8 +123,8 @@
  * @return 0 on success, -1 on error
  */
 static int
-freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int fake,
-    pkg_db_action *pkg_action)
+freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int reg __unused,
+    int fake, pkg_db_action *pkg_action)
 {
 	struct pkg_file	*contents_file;
 	struct pkg_file **control;
@@ -194,17 +194,20 @@
 		case PKG_LINE_CWD:
 			/* Change to the correct directory */
 			if (!fake) {
-			free(directory);
-			if (freebsd_do_cwd(db, pkg, contents->lines[line].data,
-			    fake) != 0) {
-				chdir(cwd);
-				free(cwd);
-				free(prefix);
-				pkg_freebsd_contents_free(contents);
-				return -1;
+				if (reg || (!reg &&
+				    strcmp(contents->lines[line].data,".")!=0)){
+					free(directory);
+					if (freebsd_do_cwd(db, pkg,
+					    contents->lines[line].data, fake) != 0) {
+						chdir(cwd);
+						free(cwd);
+						free(prefix);
+						pkg_freebsd_contents_free(contents);
+						return -1;
+					}
+					directory = getcwd(NULL, 0);
+				}
 			}
-			directory = getcwd(NULL, 0);
-			}
 			if (pkg_action != NULL)
 				pkg_action(PKG_DB_PACKAGE, "CWD to %s",
 				    contents->lines[line].data);
@@ -293,15 +296,18 @@
 
 			/* Install the file */
 			if (!fake) {
-				ret = pkg_file_write(file);
-				if (ret != 0) {
-					chdir(cwd);
-					free(cwd);
-					free(directory);
-					free(prefix);
-					pkg_file_free(file);
-					pkg_freebsd_contents_free(contents);
-					return -1;
+				if (reg ||
+				    (!reg && pkg_file_get_name(file)[0] !='+')){
+					ret = pkg_file_write(file);
+					if (ret != 0) {
+						chdir(cwd);
+						free(cwd);
+						free(directory);
+						free(prefix);
+						pkg_file_free(file);
+						pkg_freebsd_contents_free(contents);
+						return -1;
+					}
 				}
 			}
 
@@ -325,12 +331,6 @@
 		}
 	}
 
-	/* Create the new contents file */
-	if (!fake) {
-		contents_file = freebsd_build_contents(contents);
-		pkg_file_write(contents_file);
-		pkg_file_free(contents_file);
-	}
 
 	if (pkg_action != NULL)
 		pkg_action(PKG_DB_INFO, "Running mtree for %s..",
@@ -345,16 +345,24 @@
 	/** @todo pkg_action the post script */
 	pkg_run_script(pkg, pkg_script_post);
 
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO,
-		    "Attempting to record package into /var/db/pkg/%s..",
-		    pkg_get_name(pkg));
+	if (reg) {
+		if (pkg_action != NULL)
+			pkg_action(PKG_DB_INFO,
+			    "Attempting to record package into " DB_LOCATION
+			    "/%s..", pkg_get_name(pkg));
 
-	/** @todo Register the reverse dependencies */
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO,
-		    "Package %s registered in " DB_LOCATION "/%s",
-		    pkg_get_name(pkg), pkg_get_name(pkg));
+		/* Create the new contents file */
+		if (!fake) {
+			contents_file = freebsd_build_contents(contents);
+			pkg_file_write(contents_file);
+			pkg_file_free(contents_file);
+		}
+		/** @todo Register the reverse dependencies */
+		if (pkg_action != NULL)
+			pkg_action(PKG_DB_INFO,
+			    "Package %s registered in " DB_LOCATION "/%s",
+			    pkg_get_name(pkg), pkg_get_name(pkg));
+	}
 
 	free(directory);
 	if (last_file != NULL)
@@ -392,11 +400,10 @@
 	/* Does the package repo directory exist */
 	if (stat(dir, &sb) == 0 && S_ISDIR(sb.st_mode) != 0) {
 		/* The passed package is installed */
-		is_installed = 0;
+		free(dir);
+		return 0;
 	}
 	free(dir);
-	if (is_installed == 0)
-		return 0;
 
 	/* Does the package have an origin and if so is that origin installed */
 	if (pkg_get_origin(pkg) != NULL) {

Modified: trunk/src/pkg_db_private.h
===================================================================
--- trunk/src/pkg_db_private.h	2006-04-12 10:34:22 UTC (rev 92)
+++ trunk/src/pkg_db_private.h	2006-04-13 22:18:51 UTC (rev 93)
@@ -31,7 +31,7 @@
 #define __LIBPKG_PKG_DB_PRIVATE_H__
 
 typedef int	 pkg_db_install_pkg_callback(struct pkg_db *, struct pkg *, int,
-			pkg_db_action *);
+			int, pkg_db_action *);
 typedef int 	 pkg_db_is_installed_callback(struct pkg_db *, struct pkg *);
 typedef struct pkg	 *pkg_db_get_package_callback(struct pkg_db *,
 				const char *);

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-12 10:34:22 UTC (rev 92)
+++ trunk/src/pkg_freebsd.c	2006-04-13 22:18:51 UTC (rev 93)
@@ -310,7 +310,8 @@
 
 		/* Load the contents file */
 		freebsd_parse_contents(fpkg);
-		assert(fpkg->contents != NULL);
+		if (fpkg->contents == NULL)
+			return NULL;
 		assert(fpkg->contents->lines != NULL);
 
 		/* Find the line with the origin */



From zxombie at berlios.de  Fri Apr 14 00:21:26 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 14 Apr 2006 00:21:26 +0200
Subject: [Libpkg-svn] r94 - trunk/tools/pkg_add
Message-ID: <200604132221.k3DMLQni027596@sheep.berlios.de>

Author: zxombie
Date: 2006-04-14 00:21:25 +0200 (Fri, 14 Apr 2006)
New Revision: 94

Modified:
   trunk/tools/pkg_add/main.c
Log:
Use change 93 to implement the -R flag
Store the names of installed packages in a linked list. This means the -R and -n runs will only attempt to install each package once


Modified: trunk/tools/pkg_add/main.c
===================================================================
--- trunk/tools/pkg_add/main.c	2006-04-13 22:18:51 UTC (rev 93)
+++ trunk/tools/pkg_add/main.c	2006-04-13 22:21:25 UTC (rev 94)
@@ -46,6 +46,14 @@
 	char		  chroot[PATH_MAX];
 };
 
+/* A linked list of packages that have been installed */
+struct pkg_list {
+	const char *name;
+	struct pkg_list *next;
+};
+
+struct pkg_list *head = NULL;
+
 static char options[] = "hvIRfnrp:P:SMt:C:K";
 
 static void usage(void);
@@ -95,7 +103,6 @@
 			break;
 		case 'R':
 			add.flags |= no_record_install_flag;
-			errx(1, "Unsupported argument");
 			break;
 		case 'r':
 			pkg_repo_free(add.repo);
@@ -210,12 +217,25 @@
 	unsigned int i;
 	int ret;
 	struct pkg **deps;
+	struct pkg_list *cur;
 
 	assert(pkg != NULL);
 	assert(repo != NULL);
 	assert(db != NULL);
 
-	/* Don't install packages twice */
+	/*
+	 * See if the package has been marked as installed in this run.
+	 * If it has don't bother attempting to install it again
+	 */
+	cur = head;
+	while (cur != NULL) {
+		if (strcmp(cur->name, pkg_get_name(pkg)) == 0) {
+			return 0;
+		}
+		cur = cur->next;
+	}
+	
+	/* Don't install a package that has been registered in the db */
 	if (pkg_db_is_installed(db, pkg) == 0) {
 		return 0;
 	}
@@ -246,10 +266,22 @@
 	if ((flags & verbosity_flag) == verbosity_flag) {
 		printf("extract: Package name is %s\n", pkg_get_name(pkg));
 		ret = pkg_db_install_pkg_action(db, pkg,
+		    ((flags & no_record_install_flag)!= no_record_install_flag),
 		    ((flags & no_run_flag) == no_run_flag), pkg_action);
 	} else if ((flags & no_run_flag) == 0) {
-		ret = pkg_db_install_pkg(db, pkg);
+		ret = pkg_db_install_pkg(db, pkg,
+		    ((flags & no_record_install_flag)!=no_record_install_flag));
 	}
+	/*
+	 * Insert the installed package in a linked
+	 * list to stop it being installed again.
+	 */
+	if (ret == 0) {
+		cur = malloc(sizeof(struct pkg_list));
+		cur->next = head;
+		cur->name = pkg_get_name(pkg);
+		head = cur;
+	}
 	/* XXX Add warning if ret != 0 */
 	return ret;
 }



From zxombie at berlios.de  Fri Apr 14 01:55:27 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 14 Apr 2006 01:55:27 +0200
Subject: [Libpkg-svn] r95 - trunk/src
Message-ID: <200604132355.k3DNtROW026181@sheep.berlios.de>

Author: zxombie
Date: 2006-04-14 01:55:20 +0200 (Fri, 14 Apr 2006)
New Revision: 95

Modified:
   trunk/src/pkg.c
   trunk/src/pkg.h
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_freebsd.c
   trunk/src/pkg_private.h
Log:
Add pkg_(set|get)_prefix to set/get the installation prefix of a package
Use pkg_set_prefix rather than a prefix variable in freebsd_install_pkg_action.
Add pkg_script_mtree and use if when installing package. This runs the mtree on the +MTREE_DIRS file
In freebsd_run_script unlink(2) the script so rmdir(2) will remove the temp directory


Modified: trunk/src/pkg.c
===================================================================
--- trunk/src/pkg.c	2006-04-13 22:21:25 UTC (rev 94)
+++ trunk/src/pkg.c	2006-04-13 23:55:20 UTC (rev 95)
@@ -91,7 +91,8 @@
 	pkg->pkg_get_next_file = NULL;
 	pkg->pkg_run_script = NULL;
 
-	/* The data is unknown so set to NULL */	
+	/* The data is unknown so set to NULL */
+	pkg->pkg_prefix = NULL;
 	pkg->data = NULL;
 
 	return pkg;
@@ -207,6 +208,50 @@
 }
 
 /**
+ * @brief Sets the location to install the package to
+ * @param pkg The package to install
+ * @param prefix The location in the filesystem to install the package pkg to
+ * 
+ * If the prefix is set and malloc fails the old prefix is kept.
+ * Otherwise the prefix is set to the new prefix.
+ * @return 0 on success, -1 on error
+ */
+int
+pkg_set_prefix(struct pkg *pkg, const char *prefix)
+{
+	char *old_prefix;
+	if (pkg == NULL)
+		return -1;
+
+	if (prefix == NULL)
+		return -1;
+
+	old_prefix = pkg->pkg_prefix;
+	pkg->pkg_prefix = strdup(prefix);
+	if (pkg->pkg_prefix == NULL) {
+		pkg->pkg_prefix = old_prefix;
+		return -1;
+	}
+	if (old_prefix != NULL)
+		free(old_prefix);
+
+	return 0;
+}
+
+/**
+ * @brief Returns the prefix or NULL
+ * @return the prefix or NULL if it hasn't been set
+ */
+const char *
+pkg_get_prefix(struct pkg *pkg)
+{
+	if (pkg == NULL)
+		return NULL;
+
+	return pkg->pkg_prefix;
+}
+
+/**
  * @brief Gets the control files from a given package
  * 
  * @return A null-terminated array of pkg_file's contining the packages control files
@@ -413,10 +458,13 @@
 		return -1;
 	}
 
-	if (pkg->pkg_name)
+	if (pkg->pkg_name != NULL)
 		free(pkg->pkg_name);
 
-	if (pkg->pkg_free)
+	if (pkg->pkg_prefix != NULL)
+		free(pkg->pkg_prefix);
+
+	if (pkg->pkg_free != NULL)
 		pkg->pkg_free(pkg);
 
 	free(pkg);

Modified: trunk/src/pkg.h
===================================================================
--- trunk/src/pkg.h	2006-04-13 22:21:25 UTC (rev 94)
+++ trunk/src/pkg.h	2006-04-13 23:55:20 UTC (rev 95)
@@ -63,7 +63,8 @@
 typedef enum {
 	pkg_script_noop,
 	pkg_script_pre,
-	pkg_script_post
+	pkg_script_post,
+	pkg_script_mtree
 } pkg_script;
 
 struct pkg		 *pkg_new_empty(const char *);
@@ -71,6 +72,8 @@
 struct pkg		 *pkg_new_freebsd_installed(const char *, const char *);
 struct pkg		 *pkg_new_freebsd_empty(const char *);
 int			  pkg_compare(const void *, const void *);
+int			  pkg_set_prefix(struct pkg *, const char *);
+const char		 *pkg_get_prefix(struct pkg *);
 struct pkg_file		**pkg_get_control_files(struct pkg *);
 struct pkg_file		 *pkg_get_control_file(struct pkg *, const char *);
 struct pkg		**pkg_get_dependencies(struct pkg *);

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-13 22:21:25 UTC (rev 94)
+++ trunk/src/pkg_db_freebsd.c	2006-04-13 23:55:20 UTC (rev 95)
@@ -130,7 +130,7 @@
 	struct pkg_file **control;
 	struct pkg_freebsd_contents *contents;
 	char *cwd;
-	char *directory, *prefix, *last_file;
+	char *directory, *last_file;
 	int i;
 	unsigned int pos, line;
 
@@ -176,7 +176,7 @@
 
 	/* directory is used int the processing of +CONTENTS files */
 	directory = getcwd(NULL, 0);
-	prefix = strdup(directory);
+	pkg_set_prefix(pkg, directory);
 	last_file = NULL;
 
 	/** @todo pkg_action the pre script */
@@ -201,7 +201,6 @@
 					    contents->lines[line].data, fake) != 0) {
 						chdir(cwd);
 						free(cwd);
-						free(prefix);
 						pkg_freebsd_contents_free(contents);
 						return -1;
 					}
@@ -235,7 +234,6 @@
 				chdir(cwd);
 				free(cwd);
 				free(directory);
-				free(prefix);
 				pkg_freebsd_contents_free(contents);
 				return -1;
 			} else if (strncmp("MD5:", contents->lines[line+1].data,
@@ -243,7 +241,6 @@
 				chdir(cwd);
 				free(cwd);
 				free(directory);
-				free(prefix);
 				pkg_freebsd_contents_free(contents);
 				return -1;
 			}
@@ -270,7 +267,6 @@
 					chdir(cwd);
 					free(cwd);
 					free(directory);
-					free(prefix);
 					pkg_file_free(file);
 					pkg_freebsd_contents_free(contents);
 					return -1;
@@ -288,7 +284,6 @@
 				chdir(cwd);
 				free(cwd);
 				free(directory);
-				free(prefix);
 				pkg_file_free(file);
 				pkg_freebsd_contents_free(contents);
 				return -1;
@@ -303,7 +298,6 @@
 						chdir(cwd);
 						free(cwd);
 						free(directory);
-						free(prefix);
 						pkg_file_free(file);
 						pkg_freebsd_contents_free(contents);
 						return -1;
@@ -337,11 +331,8 @@
 		    pkg_get_name(pkg));
 
 	if (!fake)
-		pkg_exec("mtree -U -f +MTREE_DIRS -d -e -p %s >/dev/null",
-		    prefix);
+		pkg_run_script(pkg, pkg_script_mtree);
 
-	free(prefix);
-
 	/** @todo pkg_action the post script */
 	pkg_run_script(pkg, pkg_script_post);
 

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-13 22:21:25 UTC (rev 94)
+++ trunk/src/pkg_freebsd.c	2006-04-13 23:55:20 UTC (rev 95)
@@ -512,13 +512,15 @@
 			snprintf(arg, FILENAME_MAX, "POST-INSTALL");
 		}
 		break;
+	case pkg_script_mtree:
+		script_file = pkg_get_control_file(pkg, "+MTREE_DIRS");
+		break;
 	default:
 		return -1;
 	}
 	if (script_file == NULL)
 		return 0;
 
-	/** @todo make a tempdir, cd tempdir, extrace the file, execute it, cleanup tempdir */
 	/** @todo Add a lock around mkdtemp ad arc4random is not thread safe */
 	snprintf(dir, FILENAME_MAX, "/tmp/libpkg_XXXXXXX");
 	dir1 = mkdtemp(dir);
@@ -529,14 +531,22 @@
 
 	/* Extract the script */
 	pkg_file_write(script_file);
-	pkg_exec("chmod u+x %s", pkg_file_get_name(script_file));
+	if (script == pkg_script_mtree) {
+		const char *prefix = pkg_get_prefix(pkg);
+		pkg_exec("mtree -U -f +MTREE_DIRS -d -e -p %s >/dev/null",
+		    (prefix != NULL ? prefix : "/usr/local"));
+		unlink("+MTREE_DIRS");
+	} else { 
+		pkg_exec("chmod u+x %s", pkg_file_get_name(script_file));
+
+		/* Execute the script */
+		ret = pkg_exec("%s/%s %s %s", dir1,
+		    pkg_file_get_name(script_file), pkg_get_name(pkg), arg);
+		unlink(pkg_file_get_name(script_file));
+	}
 	chdir(cwd);
 	free(cwd);
 
-	/* Execute the script */
-	ret = pkg_exec("%s/%s %s %s", dir1, pkg_file_get_name(script_file),
-	    pkg_get_name(pkg), arg);
-
 	rmdir(dir1);
 	return ret;
 }

Modified: trunk/src/pkg_private.h
===================================================================
--- trunk/src/pkg_private.h	2006-04-13 22:21:25 UTC (rev 94)
+++ trunk/src/pkg_private.h	2006-04-13 23:55:20 UTC (rev 95)
@@ -86,6 +86,7 @@
 	void	*data;
 
 	char	*pkg_name;
+	char	*pkg_prefix;
 
 	/* Main callbacks */
 	pkg_get_control_files_callback	*pkg_get_control_files;



From zxombie at berlios.de  Fri Apr 14 02:17:42 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 14 Apr 2006 02:17:42 +0200
Subject: [Libpkg-svn] r96 - trunk
Message-ID: <200604140017.k3E0Hghx031385@sheep.berlios.de>

Author: zxombie
Date: 2006-04-14 02:17:02 +0200 (Fri, 14 Apr 2006)
New Revision: 96

Modified:
   trunk/CHANGELOG
Log:
Update the CHANGELOG


Modified: trunk/CHANGELOG
===================================================================
--- trunk/CHANGELOG	2006-04-13 23:55:20 UTC (rev 95)
+++ trunk/CHANGELOG	2006-04-14 00:17:02 UTC (rev 96)
@@ -1,3 +1,97 @@
+2006-04-14
+ * Allow packages to be installed without registering the installation
+ * Use change 93 to implement the -R flag in pkg_add
+ * Store the names of installed packages in a linked list. This means the -R and -n runs will only attempt to install each package once
+ * Add pkg_(set|get)_prefix to set/get the installation prefix of a package
+ * Use pkg_set_prefix rather than a prefix variable in freebsd_install_pkg_action
+ * Add pkg_script_mtree and use if when installing package. This runs the mtree on the +MTREE_DIRS file
+ * In freebsd_run_script unlink(2) the script so rmdir(2) will remove the temp directory
+
+2006-04-12
+ * Implement execution of pre/post installation scripts
+
+2006-04-11
+ * Check if the package's database directory exists and is a directory before creating the pkg object
+ * Return the correct value in freebsd_parse_contents when it has already been called
+ * Set contents_file to NULL at the start to make thecheck after the for loop valid
+ * Allow package installation to be faked. This is useful for "pkg_add -nv bla"
+ * Make add.verbosity add.flags with a single bit for each flag
+ * Store the -f, -I, -K, -n, -R and -v arguments in add.flags
+ * Implement -n to use the faked installation opetion of pkg_db
+ * Update the list of ftp directories to FreeBSD HEAD
+
+2006-04-10
+ * Correct the spelling of brief
+ * In pkg_freebsd the first file in fpkg->control may not be the +CONTENTS. Search for the file
+
+2006-04-07
+ * Execute the contructed string by sending it to system(3)
+ * Rewrite the FreeBSD package backend. The new backend caches more data, is simpler and should be faster
+ * Move freebsd_format_cmd to pkg_db_freebsd.c as that is where it is being used
+
+2006-03-28
+ * Document the pkg_file object
+ * Document the pkg_repo object
+ * Fix the documentation on in the internal FreeBSD functions
+ * Document the pkg_repo objects
+ * Document the util functions
+
+2006-03-23
+ * Document the pkg_db object
+ * Document the FreeBSD pkg_db object and FreeBSD +CONTENTS handeling
+
+2006-03-21
+ * Add a define pkg_static. It is defined to static unless building documentation
+ * This is to get Doxygen to build the docs for callbacks and internal functions
+ * Document the FreeBSD package functions
+
+2006-03-20
+ * Document pkg.c in a way doxygen will be able to understand
+
+2006-03-16
+ * Add the start of a pkg_add replacement
+
+2006-03-14
+ * Add support for communication from the package database to the user
+ * Add pkg_execute to execute programs by using a va_list. This is not complete
+ * Save the prefix when installing packages
+ * Use pkg_exec and prefix when installing FreeBSD packages
+
+2006-02-23
+ * Make WARNS=6 compliant by making the data taken by freebsd_get_installed_match of type `const void *'
+ * Rename the link argument in pkg_file_new_symlink to lnk to not conflict with link(2)
+
+2006-02-22
+ * Check ftp_get_fd returns a valid pointer
+ * Make pkg_compare WARNS=6 complant
+ * Make src/Makefile easyer to read
+
+2006-02-20
+ * Silence a warning about NOMAN being depricated
+
+2006-02-08
+ * Add support to pkg_file for symlinks
+ * Create symlinks when the tarball contains them
+ * Add pkg_repo_local_freebsd to search for packages in . and /usr/ports/packages/All
+
+2006-02-07
+ * Add pkg_match_by_origin to match all packages with a given origin
+ * Update freebsd_is_installed to use pkg_match_by_origin to find if the package is installed
+
+2006-02-06
+ * Change pkg_db_is_installed to take a pkg object rather than a package name
+
+2006-02-04
+ * Make pkg_get_name, pkg_get_version and pkg_get_version return "const char *" rather than "char *"
+ * Catch up with using const char * in pkg_get_name, pkg_get_version and pkg_get_version
+ * Update README on building on Linux
+
+2006-02-03
+ * Fix _pkg_match_regex when there are multiple regex strings
+ * Reduce the amount of code by merging the MATCH_ALL, MATCH_REGEX and MATCH_EREGEX cases
+ * Add WITH_PROFILING make option to build a profiling binary
+ * Change the indentation in the Makefile
+
 2006-02-02
  * Update the manual pages.
  * Reorder functions to match the order in the manual pages



From zxombie at berlios.de  Fri Apr 14 02:22:15 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 14 Apr 2006 02:22:15 +0200
Subject: [Libpkg-svn] r97 - trunk
Message-ID: <200604140022.k3E0MFMf031645@sheep.berlios.de>

Author: zxombie
Date: 2006-04-14 02:21:38 +0200 (Fri, 14 Apr 2006)
New Revision: 97

Modified:
   trunk/README
Log:
Remove problems that have been solved from the README


Modified: trunk/README
===================================================================
--- trunk/README	2006-04-14 00:17:02 UTC (rev 96)
+++ trunk/README	2006-04-14 00:21:38 UTC (rev 97)
@@ -13,9 +13,6 @@
 
 Problems:
     * It can only install packages not uninstall or create them.
-    * Can't get a list of installed packages.
-    * There is no dependency handling.
     * Dosn't follow style(9).
     * Not all possible lines in +CONTENTS are handled.
-    * @exec lines in +CONTENTS aren't executed.
     * A failed install will leave files with no package.



From zxombie at berlios.de  Fri Apr 14 02:27:21 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 14 Apr 2006 02:27:21 +0200
Subject: [Libpkg-svn] r98 - tags
Message-ID: <200604140027.k3E0RLcm032239@sheep.berlios.de>

Author: zxombie
Date: 2006-04-14 02:26:55 +0200 (Fri, 14 Apr 2006)
New Revision: 98

Added:
   tags/libpkg-0.1.20060414/
Log:
Tag the 0.1.20060414 release


Copied: tags/libpkg-0.1.20060414 (from rev 97, trunk)



From zxombie at berlios.de  Fri Apr 21 03:12:21 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 21 Apr 2006 03:12:21 +0200
Subject: [Libpkg-svn] r99 - trunk/src
Message-ID: <200604210112.k3L1CLQA026706@sheep.berlios.de>

Author: zxombie
Date: 2006-04-21 03:12:06 +0200 (Fri, 21 Apr 2006)
New Revision: 99

Modified:
   trunk/src/pkg.h
   trunk/src/pkg_freebsd.c
Log:
Add support for executing a script that will check to see if the package can be installed


Modified: trunk/src/pkg.h
===================================================================
--- trunk/src/pkg.h	2006-04-14 00:26:55 UTC (rev 98)
+++ trunk/src/pkg.h	2006-04-21 01:12:06 UTC (rev 99)
@@ -64,7 +64,8 @@
 	pkg_script_noop,
 	pkg_script_pre,
 	pkg_script_post,
-	pkg_script_mtree
+	pkg_script_mtree,
+	pkg_script_require
 } pkg_script;
 
 struct pkg		 *pkg_new_empty(const char *);

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-14 00:26:55 UTC (rev 98)
+++ trunk/src/pkg_freebsd.c	2006-04-21 01:12:06 UTC (rev 99)
@@ -515,6 +515,9 @@
 	case pkg_script_mtree:
 		script_file = pkg_get_control_file(pkg, "+MTREE_DIRS");
 		break;
+	case pkg_script_require:
+		script_file = pkg_get_control_file(pkg, "+REQUIRE");
+		break;
 	default:
 		return -1;
 	}
@@ -531,19 +534,32 @@
 
 	/* Extract the script */
 	pkg_file_write(script_file);
-	if (script == pkg_script_mtree) {
+	switch(script) {
+	case pkg_script_mtree:
+	{
 		const char *prefix = pkg_get_prefix(pkg);
 		pkg_exec("mtree -U -f +MTREE_DIRS -d -e -p %s >/dev/null",
 		    (prefix != NULL ? prefix : "/usr/local"));
-		unlink("+MTREE_DIRS");
-	} else { 
+		break;
+	}
+	case pkg_script_pre:
+	case pkg_script_post:
 		pkg_exec("chmod u+x %s", pkg_file_get_name(script_file));
 
 		/* Execute the script */
 		ret = pkg_exec("%s/%s %s %s", dir1,
 		    pkg_file_get_name(script_file), pkg_get_name(pkg), arg);
-		unlink(pkg_file_get_name(script_file));
+		break;
+	case pkg_script_require:
+		pkg_exec("chmod u+x %s", pkg_file_get_name(script_file));
+
+		ret = pkg_exec("%s/%s %s INSTALL", dir1,
+		    pkg_file_get_name(script_file), pkg_get_name(pkg));
+		break;
+	case pkg_script_noop:
+		break;
 	}
+	unlink(pkg_file_get_name(script_file));
 	chdir(cwd);
 	free(cwd);
 



From zxombie at berlios.de  Fri Apr 21 03:15:53 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Fri, 21 Apr 2006 03:15:53 +0200
Subject: [Libpkg-svn] r100 - trunk/src
Message-ID: <200604210115.k3L1FrLR027713@sheep.berlios.de>

Author: zxombie
Date: 2006-04-21 03:15:47 +0200 (Fri, 21 Apr 2006)
New Revision: 100

Modified:
   trunk/src/pkg_db_freebsd.c
Log:
Add the start of a reworked package installation callback.


Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-21 01:12:06 UTC (rev 99)
+++ trunk/src/pkg_db_freebsd.c	2006-04-21 01:15:47 UTC (rev 100)
@@ -70,6 +70,10 @@
 pkg_static struct pkg	 *freebsd_get_package(struct pkg_db *, const char *);	
 
 /* Internal */
+#ifdef NEW_DB
+pkg_static int			 freebsd_do_install(struct pkg_db *,
+				struct pkg *);
+#else
 pkg_static struct pkg_file	*freebsd_build_contents(
 				struct pkg_freebsd_contents *);
 pkg_static int			 freebsd_do_cwd(struct pkg_db *, struct pkg *,
@@ -78,6 +82,7 @@
 				struct pkg_freebsd_contents *, int);
 pkg_static void			 freebsd_format_cmd(char *, int, const char *,
 				const char *, const char *);
+#endif
 
 /**
  * @defgroup PackageDBFreebsd FreeBSD Package Database handeling
@@ -123,9 +128,10 @@
  * @return 0 on success, -1 on error
  */
 static int
-freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int reg __unused,
+freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int reg,
     int fake, pkg_db_action *pkg_action)
 {
+#ifndef NEW_DB
 	struct pkg_file	*contents_file;
 	struct pkg_file **control;
 	struct pkg_freebsd_contents *contents;
@@ -133,15 +139,64 @@
 	char *directory, *last_file;
 	int i;
 	unsigned int pos, line;
+#endif
 
+	assert(db != NULL);
 	assert(pkg != NULL);
 
+#ifdef NEW_DB
+	/* Run +REQUIRE */
+	if (pkg_action != NULL)
+		pkg_action(PKG_DB_INFO, "Running pre-install for %s..",
+		    pkg_get_name(pkg));
+
+	if (!fake) {
+		/** @todo Check if the force flag is set */
+		if (pkg_run_script(pkg, pkg_script_require) != 0) {
+			return -1;
+		}
+	}
+
+	/* Run Pre-install */
+	if (pkg_action != NULL)
+		pkg_action(PKG_DB_INFO, "Running pre-install for %s..",
+		    pkg_get_name(pkg));
+
+	if (!fake)
+		pkg_run_script(pkg, pkg_script_pre);
+
+	/* Do the Install */
+	freebsd_do_install(db, pkg);
+
+	/* Extract the +MTREE */
+	if (pkg_action != NULL)
+		pkg_action(PKG_DB_INFO, "Running mtree for %s..",
+		    pkg_get_name(pkg));
+
+	if (!fake)
+		pkg_run_script(pkg, pkg_script_mtree);
+
+	/* Run post-install */
+	if (pkg_action != NULL)
+		pkg_action(PKG_DB_INFO, "Running post-install for %s..",
+		    pkg_get_name(pkg));
+
+	if (!fake)
+		pkg_run_script(pkg, pkg_script_post);
+
+	/* Record the package installation */
+	if (!fake && reg) {
+	}
+
+	/* Display contents of @display */
+#else
+	/* Get the control files from the package */
 	control = pkg_get_control_files(pkg);
 	if (!control) {
 		return -1;
 	}
 
-	/* Find the contents file in the control files */
+	/* Find the +CONTENTS file in the control files */
 	for (pos = 0; control[pos] != NULL; pos++)
 		if (!strcmp(control[pos]->filename, "+CONTENTS"))
 			break;
@@ -363,6 +418,7 @@
 
 	pkg_freebsd_contents_free(contents);
 
+#endif
 	return 0;
 }
 
@@ -489,6 +545,14 @@
  * @{
  */
 
+#ifdef NEW_DB
+static int
+freebsd_do_install(struct pkg_db *db __unused, struct pkg *pkg __unused)
+{
+	return -1;
+}
+
+#else
 /**
  * @brief Internal function to to the correct thing for an \@cwd line
  * @return 0 if successful or -1 on error
@@ -740,6 +804,7 @@
 	}
 	*buf = '\0';
 }
+#endif
 
 /**
  * @}



From zxombie at berlios.de  Mon Apr 24 03:21:52 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Mon, 24 Apr 2006 03:21:52 +0200
Subject: [Libpkg-svn] r101 - trunk/src
Message-ID: <200604240121.k3O1LqWF022654@sheep.berlios.de>

Author: zxombie
Date: 2006-04-24 03:21:39 +0200 (Mon, 24 Apr 2006)
New Revision: 101

Modified:
   trunk/src/pkg_freebsd_contents.c
Log:
As there is no data associated with files make sure it is NULL


Modified: trunk/src/pkg_freebsd_contents.c
===================================================================
--- trunk/src/pkg_freebsd_contents.c	2006-04-21 01:15:47 UTC (rev 100)
+++ trunk/src/pkg_freebsd_contents.c	2006-04-24 01:21:39 UTC (rev 101)
@@ -119,6 +119,7 @@
 		cont->lines[0].line = cont->file;
 		pos = 1;
 		while (pos < cont->line_count) {
+			cont->lines[pos].data = NULL;
 			cont->lines[pos].line = strchr(cont->lines[pos-1].line, '\n');
 			if (cont->lines[pos].line) {
 				/* Terminate the last line */
@@ -153,6 +154,7 @@
 			/* Get the correct line type for the line */
 			if (cont->lines[pos].line[0] != '@') {
 				cont->lines[pos].line_type = PKG_LINE_FILE;
+				assert(cont->lines[pos].data == NULL);
 			} else if (!strcmp(cont->lines[pos].line, "@comment")) {
 				cont->lines[pos].line_type = PKG_LINE_COMMENT;
 			} else if (!strcmp(cont->lines[pos].line, "@name")) {
@@ -218,6 +220,7 @@
 	if (type == PKG_LINE_FILE) {
 		contents->lines[contents->line_count].line = strdup(data);
 		assert(contents->lines[contents->line_count].line != NULL);
+		assert(contents->lines[contents->line_count].data == NULL);
 	} else {
 		contents->lines[contents->line_count].line =
 		    strdup(pkg_freebsd_contents_line_str[type]);



From zxombie at berlios.de  Mon Apr 24 04:01:40 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Mon, 24 Apr 2006 04:01:40 +0200
Subject: [Libpkg-svn] r102 - trunk/src
Message-ID: <200604240201.k3O21eeB002533@sheep.berlios.de>

Author: zxombie
Date: 2006-04-24 04:00:42 +0200 (Mon, 24 Apr 2006)
New Revision: 102

Modified:
   trunk/src/pkg_freebsd.h
   trunk/src/pkg_freebsd_contents.c
Log:
Reorder the line type enum to a more sensible order
Add support to decode @display lines


Modified: trunk/src/pkg_freebsd.h
===================================================================
--- trunk/src/pkg_freebsd.h	2006-04-24 01:21:39 UTC (rev 101)
+++ trunk/src/pkg_freebsd.h	2006-04-24 02:00:42 UTC (rev 102)
@@ -34,17 +34,18 @@
 
 enum {
 	PKG_LINE_UNKNOWN = 0,
-	PKG_LINE_COMMENT = 1,
-	PKG_LINE_NAME = 2,
-	PKG_LINE_CWD = 3,
-	PKG_LINE_PKGDEP = 4,
-	PKG_LINE_CONFLICTS = 5,
-	PKG_LINE_EXEC = 6,
-	PKG_LINE_UNEXEC = 7,
-	PKG_LINE_IGNORE = 8,
-	PKG_LINE_DIRRM = 9,
-	PKG_LINE_MTREE = 10,
-	PKG_LINE_FILE = 11
+	PKG_LINE_FILE = 1,
+	PKG_LINE_COMMENT = 2,
+	PKG_LINE_NAME = 3,
+	PKG_LINE_CWD = 4,
+	PKG_LINE_PKGDEP = 5,
+	PKG_LINE_CONFLICTS = 6,
+	PKG_LINE_EXEC = 7,
+	PKG_LINE_UNEXEC = 8,
+	PKG_LINE_IGNORE = 9,
+	PKG_LINE_DIRRM = 10,
+	PKG_LINE_MTREE = 11,
+	PKG_LINE_DISPLAY = 12
 };
 
 struct pkg_freebsd_contents_line {

Modified: trunk/src/pkg_freebsd_contents.c
===================================================================
--- trunk/src/pkg_freebsd_contents.c	2006-04-24 01:21:39 UTC (rev 101)
+++ trunk/src/pkg_freebsd_contents.c	2006-04-24 02:00:42 UTC (rev 102)
@@ -51,6 +51,7 @@
  */
 static const char *pkg_freebsd_contents_line_str[] = {
 	"",
+	"",
 	"@comment",
 	"@name",
 	"@cwd",
@@ -61,6 +62,7 @@
 	"@ignore",
 	"@dirrm",
 	"@mtree",
+	"@display",
 	NULL
 };
 
@@ -176,6 +178,8 @@
 				cont->lines[pos].line_type = PKG_LINE_DIRRM;
 			} else if (!strcmp(cont->lines[pos].line, "@mtree")) {
 				cont->lines[pos].line_type = PKG_LINE_MTREE;
+			} else if (!strcmp(cont->lines[pos].line, "@display")) {
+				cont->lines[pos].line_type = PKG_LINE_DISPLAY;
 			} else {
 				cont->lines[pos].line_type = PKG_LINE_UNKNOWN;
 				fprintf(stderr, "Unknown line type %s\n",



From zxombie at berlios.de  Mon Apr 24 12:47:05 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Mon, 24 Apr 2006 12:47:05 +0200
Subject: [Libpkg-svn] r103 - trunk/src
Message-ID: <200604241047.k3OAl5Xg006391@sheep.berlios.de>

Author: zxombie
Date: 2006-04-24 12:46:40 +0200 (Mon, 24 Apr 2006)
New Revision: 103

Modified:
   trunk/src/pkg.c
   trunk/src/pkg_db.c
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_freebsd.c
   trunk/src/pkg_private.h
Log:
Add pkg_action_null, a pkg_action callback to do nothing. This means the check to se if pkg_action is NULL can be removed
Add pkg_install, an internal function to install packages. This removes the need to know the internals of a package from pkg_db.
Make pkg_freebsd know how to install it's self to a given database by using the pkg_install function


Modified: trunk/src/pkg.c
===================================================================
--- trunk/src/pkg.c	2006-04-24 02:00:42 UTC (rev 102)
+++ trunk/src/pkg.c	2006-04-24 10:46:40 UTC (rev 103)
@@ -90,6 +90,7 @@
 	pkg->pkg_add_file = NULL;
 	pkg->pkg_get_next_file = NULL;
 	pkg->pkg_run_script = NULL;
+	pkg->pkg_install = NULL;
 
 	/* The data is unknown so set to NULL */
 	pkg->pkg_prefix = NULL;
@@ -150,12 +151,14 @@
  */
 int
 pkg_add_callbacks_install (struct pkg *pkg,
+		pkg_install_callback *install,
 		pkg_get_next_file_callback *next_file,
 		pkg_run_script_callback *run_script)
 {
 	if (pkg == NULL)
 		return -1;
 
+	pkg->pkg_install = install;
 	pkg->pkg_get_next_file = next_file;
 	pkg->pkg_run_script = run_script;
 	return 0;
@@ -424,6 +427,23 @@
 	return -1;
 }
 
+int
+pkg_install(struct pkg *pkg, int reg, pkg_db_action * pkg_action, void *data,
+		pkg_db_chdir *db_chdir,	pkg_db_install_file *install_file,
+		pkg_db_exec *do_exec)
+{
+	if (pkg == NULL || data == NULL || db_chdir == NULL ||
+	    install_file == NULL || do_exec == NULL)
+		return -1;
+
+	if (pkg->pkg_install == NULL)
+		return -1;
+
+	return pkg->pkg_install(pkg, reg, pkg_action, data, db_chdir,
+	    install_file, do_exec);
+}
+
+
 /**
  * @brief Frees a NULL terminated array of packages
  *

Modified: trunk/src/pkg_db.c
===================================================================
--- trunk/src/pkg_db.c	2006-04-24 02:00:42 UTC (rev 102)
+++ trunk/src/pkg_db.c	2006-04-24 10:46:40 UTC (rev 103)
@@ -105,6 +105,11 @@
 	return db;
 }
 
+static void
+pkg_action_null(int level __unused, const char *fmt __unused, ...)
+{
+}
+
 /**
  * @}
  */
@@ -157,6 +162,9 @@
 		return -1;
 	}
 
+	if (action == NULL)
+		action = pkg_action_null;
+
 	return db->pkg_install(db, pkg, reg, fake, action);
 }
 

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-24 02:00:42 UTC (rev 102)
+++ trunk/src/pkg_db_freebsd.c	2006-04-24 10:46:40 UTC (rev 103)
@@ -39,6 +39,8 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <md5.h>
+
 #include "pkg.h"
 #include "pkg_db.h"
 #include "pkg_freebsd.h"
@@ -48,6 +50,14 @@
 
 #define DB_LOCATION	"/var/db/pkg"
 
+#ifdef NEW_DB
+struct pkg_install_data {
+	int fake;
+	struct pkg_db *db;
+	char last_file[FILENAME_MAX];
+	char directory[MAXPATHLEN];
+};
+#endif
 /*
  * State transition array for the head part of a +CONTENTS file.
  * p0 is the start state, p4 and p6 are the accepting states
@@ -71,8 +81,16 @@
 
 /* Internal */
 #ifdef NEW_DB
+pkg_static int	freebsd_do_chdir(struct pkg *, pkg_db_action *, void *,
+				const char *);
+pkg_static int	freebsd_install_file(struct pkg *, pkg_db_action *, void *,
+				struct pkg_file *);
+pkg_static int	freebsd_do_exec(struct pkg *, pkg_db_action *, void *,
+				const char *);
+#ifdef DEAD
 pkg_static int			 freebsd_do_install(struct pkg_db *,
-				struct pkg *);
+				struct pkg *, int, pkg_db_action *);
+#endif
 #else
 pkg_static struct pkg_file	*freebsd_build_contents(
 				struct pkg_freebsd_contents *);
@@ -80,9 +98,9 @@
 				char *, int);
 pkg_static int			 freebsd_check_contents(struct pkg_db *,
 				struct pkg_freebsd_contents *, int);
+#endif
 pkg_static void			 freebsd_format_cmd(char *, int, const char *,
 				const char *, const char *);
-#endif
 
 /**
  * @defgroup PackageDBFreebsd FreeBSD Package Database handeling
@@ -139,16 +157,20 @@
 	char *directory, *last_file;
 	int i;
 	unsigned int pos, line;
+#else
+	struct pkg_install_data install_data;
 #endif
 
 	assert(db != NULL);
 	assert(pkg != NULL);
+	assert(pkg_action != NULL);
 
 #ifdef NEW_DB
+	pkg_action(PKG_DB_PACKAGE, "Package name is %s", pkg_get_name(pkg));
+
 	/* Run +REQUIRE */
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO, "Running pre-install for %s..",
-		    pkg_get_name(pkg));
+	pkg_action(PKG_DB_INFO, "Running ... for %s..",
+	    pkg_get_name(pkg));
 
 	if (!fake) {
 		/** @todo Check if the force flag is set */
@@ -158,28 +180,30 @@
 	}
 
 	/* Run Pre-install */
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO, "Running pre-install for %s..",
-		    pkg_get_name(pkg));
+	pkg_action(PKG_DB_INFO, "Running pre-install for %s..",
+	    pkg_get_name(pkg));
 
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_pre);
 
 	/* Do the Install */
-	freebsd_do_install(db, pkg);
+	install_data.db = db;
+	install_data.fake = 0;
+	if (fake) {
+		install_data.fake = 1;
+	}
+	pkg_install(pkg, reg, pkg_action, &install_data, freebsd_do_chdir,
+	    freebsd_install_file, freebsd_do_exec);
 
 	/* Extract the +MTREE */
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO, "Running mtree for %s..",
-		    pkg_get_name(pkg));
+	pkg_action(PKG_DB_INFO, "Running mtree for %s..", pkg_get_name(pkg));
 
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_mtree);
 
 	/* Run post-install */
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO, "Running post-install for %s..",
-		    pkg_get_name(pkg));
+	pkg_action(PKG_DB_INFO, "Running post-install for %s..",
+	    pkg_get_name(pkg));
 
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_post);
@@ -210,9 +234,7 @@
 		return -1;
 	}
 
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_PACKAGE, "Package name is %s",
-		    pkg_get_name(pkg));
+	pkg_action(PKG_DB_PACKAGE, "Package name is %s", pkg_get_name(pkg));
 
 	cwd = getcwd(NULL, 0);
 	if (!cwd) {
@@ -262,9 +284,8 @@
 					directory = getcwd(NULL, 0);
 				}
 			}
-			if (pkg_action != NULL)
-				pkg_action(PKG_DB_PACKAGE, "CWD to %s",
-				    contents->lines[line].data);
+			pkg_action(PKG_DB_PACKAGE, "CWD to %s",
+			    contents->lines[line].data);
 			break;
 		case PKG_LINE_EXEC: {
 			char cmd[FILENAME_MAX];
@@ -272,8 +293,7 @@
 			    contents->lines[line].data, directory, last_file);
 			if (!fake)
 				pkg_exec(cmd);
-			if (pkg_action != NULL)
-				pkg_action(PKG_DB_PACKAGE, "execute '%s'", cmd);
+			pkg_action(PKG_DB_PACKAGE, "execute '%s'", cmd);
 			break;
 		}
 		case PKG_LINE_FILE: {
@@ -326,9 +346,8 @@
 					pkg_freebsd_contents_free(contents);
 					return -1;
 				}
-				if (pkg_action != NULL)
-					pkg_action(PKG_DB_PACKAGE, "%s/%s",
-					    directory, pkg_file_get_name(file));
+				pkg_action(PKG_DB_PACKAGE, "%s/%s", directory,
+				    pkg_file_get_name(file));
 			}
 
 			contents_sum = strchr(contents->lines[line+1].data,
@@ -381,9 +400,7 @@
 	}
 
 
-	if (pkg_action != NULL)
-		pkg_action(PKG_DB_INFO, "Running mtree for %s..",
-		    pkg_get_name(pkg));
+	pkg_action(PKG_DB_INFO, "Running mtree for %s..", pkg_get_name(pkg));
 
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_mtree);
@@ -392,10 +409,9 @@
 	pkg_run_script(pkg, pkg_script_post);
 
 	if (reg) {
-		if (pkg_action != NULL)
-			pkg_action(PKG_DB_INFO,
-			    "Attempting to record package into " DB_LOCATION
-			    "/%s..", pkg_get_name(pkg));
+		pkg_action(PKG_DB_INFO,
+		    "Attempting to record package into " DB_LOCATION "/%s..",
+		    pkg_get_name(pkg));
 
 		/* Create the new contents file */
 		if (!fake) {
@@ -404,10 +420,9 @@
 			pkg_file_free(contents_file);
 		}
 		/** @todo Register the reverse dependencies */
-		if (pkg_action != NULL)
-			pkg_action(PKG_DB_INFO,
-			    "Package %s registered in " DB_LOCATION "/%s",
-			    pkg_get_name(pkg), pkg_get_name(pkg));
+		pkg_action(PKG_DB_INFO,
+		    "Package %s registered in " DB_LOCATION "/%s",
+		    pkg_get_name(pkg), pkg_get_name(pkg));
 	}
 
 	free(directory);
@@ -547,11 +562,80 @@
 
 #ifdef NEW_DB
 static int
-freebsd_do_install(struct pkg_db *db __unused, struct pkg *pkg __unused)
+freebsd_do_chdir(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
+		const char *dir)
 {
+	struct pkg_install_data *install_data;
+	struct pkg_db *db;
+
+	assert(pkg != NULL);
+	assert(pkg_action != NULL);
+	assert(data != NULL);
+	assert(dir != NULL);
+	
+	install_data = data;
+	db = install_data->db;
+	assert(db != NULL);
+	assert(db->db_base != NULL);
+
+	if (strcmp(dir, ".") == 0) {
+		snprintf(install_data->directory, MAXPATHLEN,
+		    "%s" DB_LOCATION "/%s", db->db_base, pkg_get_name(pkg));
+		if (install_data->fake != 0)
+			pkg_dir_build(install_data->directory);
+	} else {
+		snprintf(install_data->directory, MAXPATHLEN, "%s/%s",
+		    db->db_base, dir);
+	}
+
+	pkg_action(PKG_DB_PACKAGE, "CWD to %s", install_data->directory);
+	if (install_data->fake != 0)
+		return chdir(install_data->directory);
+
+	return 0;
+}
+
+static int
+freebsd_install_file(struct pkg *pkg, pkg_db_action *pkg_action __unused,
+		void *data, struct pkg_file *file)
+{
+	struct pkg_install_data *install_data;
+
+	assert(pkg != NULL);
+	assert(data != NULL);
+	assert(file != NULL);
+
+	install_data = data;
+	snprintf(install_data->last_file, FILENAME_MAX, "%s",
+	    pkg_file_get_name(file));
+	printf("%s\n", pkg_file_get_name(file));
 	return -1;
 }
 
+static int
+freebsd_do_exec(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
+		const char *cmd)
+{
+	char the_cmd[FILENAME_MAX];
+	struct pkg_install_data *install_data;
+
+	assert(pkg != NULL);
+	assert(pkg_action != NULL);
+	assert(data != NULL);
+	assert(cmd != NULL);
+
+	install_data = data;
+
+	freebsd_format_cmd(the_cmd, FILENAME_MAX, cmd, install_data->directory,
+	    install_data->last_file);
+
+	pkg_action(PKG_DB_PACKAGE, "execute '%s'", the_cmd);
+	if (install_data->fake != 0)
+		return pkg_exec(the_cmd);
+
+	return 0;
+}
+
 #else
 /**
  * @brief Internal function to to the correct thing for an \@cwd line
@@ -724,6 +808,7 @@
 	}
 	return i;
 }
+#endif
 
 /**
  * @brief Creates a string containing the command to run using printf
@@ -804,7 +889,6 @@
 	}
 	*buf = '\0';
 }
-#endif
 
 /**
  * @}

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-24 02:00:42 UTC (rev 102)
+++ trunk/src/pkg_freebsd.c	2006-04-24 10:46:40 UTC (rev 103)
@@ -55,6 +55,9 @@
 pkg_static struct pkg_file	 *freebsd_get_control_file(struct pkg *,
 					const char *);
 pkg_static struct pkg_file	 *freebsd_get_next_file(struct pkg *);
+pkg_static int			  freebsd_install(struct pkg *, int,
+					pkg_db_action *, void *, pkg_db_chdir *,
+				       	pkg_db_install_file *, pkg_db_exec *);
 pkg_static struct pkg		**freebsd_get_deps(struct pkg *);
 pkg_static int			  freebsd_run_script(struct pkg *, pkg_script);
 pkg_static int			  freebsd_free(struct pkg *);
@@ -148,7 +151,7 @@
 		return NULL;
 	}
 	pkg_add_callbacks_data(pkg, freebsd_get_version, freebsd_get_origin);
-	pkg_add_callbacks_install(pkg, freebsd_get_next_file,
+	pkg_add_callbacks_install(pkg, freebsd_install, freebsd_get_next_file,
 	    freebsd_run_script);
 	pkg->data = fpkg;
 
@@ -404,15 +407,160 @@
 	return NULL;
 }
 
+static int
+freebsd_install(struct pkg *pkg, int reg, pkg_db_action *pkg_action, void *data,
+		pkg_db_chdir *db_chdir, pkg_db_install_file *install_file,
+		pkg_db_exec *do_exec)
+{
+	int ret;
+	unsigned int pos;
+	struct pkg_file **control;
+	struct pkg_file *contents_file;
+	struct pkg_freebsd_contents *contents;
+
+	assert(pkg != NULL);
+	assert(pkg_action != NULL);
+	assert(data != NULL);
+	assert(db_chdir != NULL);
+	assert(install_file != NULL);
+
+	ret = -1;
+	contents = NULL;
+
+	/* Get the control files from the package */
+	control = pkg_get_control_files(pkg);
+	if (control == NULL) {
+		return -1;
+	}
+
+	/* Find the +CONTENTS file in the control files */
+	for (pos = 0; control[pos] != NULL; pos++)
+		if (!strcmp(control[pos]->filename, "+CONTENTS"))
+			break;
+	contents_file = control[pos];
+	if (contents_file == NULL) {
+		return -1;
+	}
+
+	contents = pkg_freebsd_contents_new(pkg_file_get(contents_file));
+	if (contents == NULL) {
+		return -1;
+	}
+
+	for (pos = 0; pos < contents->line_count; pos++) {
+		char ignore;
+
+		ignore = 0;
+		if (contents->lines[pos].line_type == PKG_LINE_IGNORE) {
+			ignore = ~0;
+			pos++;
+		}
+		switch (contents->lines[pos].line_type) {
+		case PKG_LINE_IGNORE:
+			/* Error in contents file */
+			ret = -1;
+			goto exit;
+		case PKG_LINE_COMMENT:
+		case PKG_LINE_UNEXEC:
+		case PKG_LINE_DIRRM:
+		case PKG_LINE_MTREE:
+		case PKG_LINE_PKGDEP:
+			break;
+		case PKG_LINE_NAME:
+			/* Check the name is the same as the packages name */
+			if (strcmp(pkg_get_name(pkg),
+			    contents->lines[pos].data) != 0) {
+				ret = -1;
+				goto exit;
+			}
+			break;
+		case PKG_LINE_CWD:
+		{
+			const char *dir;
+
+			dir = contents->lines[pos].data;
+			if (strcmp(dir, ".") == 0) {
+				if (reg)
+					db_chdir(pkg, pkg_action, data, dir);
+			} else {
+				db_chdir(pkg, pkg_action, data, dir);
+			}
+			break;
+		}
+		case PKG_LINE_FILE:
+		{
+			struct pkg_file *file;
+
+			file = pkg_get_next_file(pkg);
+			if (file == NULL)
+				file = pkg_get_control_file(pkg,
+				    contents->lines[pos].line);
+			if (file == NULL) {
+				/* File not found in the package */
+				ret = -1;
+				goto exit;
+			}
+
+			/* Check the file name is correct */
+			if (strcmp(contents->lines[pos].line,
+			    pkg_file_get_name(file)) != 0) {
+				ret = -1;
+				goto exit;
+			}
+
+			if (contents->lines[pos+1].line_type ==
+			    PKG_LINE_COMMENT) {
+				char *p;
+
+				p = strchr(contents->lines[pos+1].data, ':');
+				p++;
+				if (pkg_checksum_md5(file, p) == 0) {
+					/** @todo Install the file */
+					install_file(pkg, pkg_action, data,
+					    file);
+				} else {
+					ret = -1;
+					goto exit;
+				}
+				pos++;
+			}
+//			if (ignore)
+//				printf(" (Ignored)");
+			break;
+		}
+		case PKG_LINE_EXEC:
+		{
+			do_exec(pkg, pkg_action, data,
+			    contents->lines[pos].data);
+			break;
+		}
+
+		default:
+			printf("%s", contents->lines[pos].line);
+			if (contents->lines[pos].data != NULL)
+				printf(" %s", contents->lines[pos].data);
+			if (ignore)
+				printf(" (Ignored)");
+			putchar('\n');
+		}
+	}
+exit:
+	if (contents != NULL)
+		pkg_freebsd_contents_free(contents);
+
+	return ret;
+}
+
 /**
  * @brief Callback for pkg_get_next_file()
- * @todo Write
  * @return The next non-control pkg_file or NULL
  */
 static struct pkg_file *
 freebsd_get_next_file(struct pkg *pkg)
 {
 	struct freebsd_package *fpkg;
+	struct pkg_file *file;
+
 	assert(pkg != NULL);
 	fpkg = pkg->data;
 	assert(fpkg != NULL);
@@ -423,7 +571,15 @@
 		fpkg->next_file = NULL;
 		return pkg_file;
 	}
-	return freebsd_get_next_entry(fpkg->archive);
+	if (fpkg->archive == NULL)
+		return NULL;
+
+	file = freebsd_get_next_entry(fpkg->archive);
+	if (file == NULL) {
+		archive_read_finish(fpkg->archive);
+		fpkg->archive = NULL;
+	}
+	return file;
 }
 
 /**

Modified: trunk/src/pkg_private.h
===================================================================
--- trunk/src/pkg_private.h	2006-04-24 02:00:42 UTC (rev 102)
+++ trunk/src/pkg_private.h	2006-04-24 10:46:40 UTC (rev 103)
@@ -31,6 +31,7 @@
 #define __LIBPKG_PKG_PRIVATE_H__
 
 #include <archive.h>
+#include "pkg_db.h"
 
 int archive_read_open_stream(struct archive *, FILE *, size_t);
 
@@ -76,11 +77,24 @@
 				pkg_add_file_callback *);
 
 /* Callbacks used with installable packages. Used by pkg_repo */
+typedef int	  	  pkg_db_chdir(struct pkg *, pkg_db_action *, void *,
+				const char *);
+typedef int		  pkg_db_install_file(struct pkg *, pkg_db_action *,
+				void *, struct pkg_file *);
+typedef int		  pkg_db_exec(struct pkg *, pkg_db_action *, void *,
+				const char *);
+typedef int	  	  pkg_install_callback(struct pkg*, int,
+				pkg_db_action *, void *, pkg_db_chdir *,
+				pkg_db_install_file *, pkg_db_exec *);
 typedef struct pkg_file	 *pkg_get_next_file_callback(struct pkg *);
 typedef int		  pkg_run_script_callback(struct pkg *, pkg_script);
 int			  pkg_add_callbacks_install(struct pkg *,
+				pkg_install_callback *,
 				pkg_get_next_file_callback *,
 				pkg_run_script_callback *);
+int			  pkg_install(struct pkg *, int, pkg_db_action *,
+				void *, pkg_db_chdir *, pkg_db_install_file *,
+				pkg_db_exec *);
 
 struct pkg {
 	void	*data;
@@ -102,6 +116,7 @@
 	pkg_add_file_callback		*pkg_add_file;
 
 	/* Callbacks used with installing packages */
+	pkg_install_callback		*pkg_install;
 	pkg_get_next_file_callback	*pkg_get_next_file;
 	pkg_run_script_callback		*pkg_run_script;
 };



From zxombie at berlios.de  Tue Apr 25 04:56:05 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 25 Apr 2006 04:56:05 +0200
Subject: [Libpkg-svn] r104 - trunk/src
Message-ID: <200604250256.k3P2u5LC020085@sheep.berlios.de>

Author: zxombie
Date: 2006-04-25 04:54:57 +0200 (Tue, 25 Apr 2006)
New Revision: 104

Modified:
   trunk/src/pkg.c
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_freebsd.c
   trunk/src/pkg_private.h
Log:
Add a package registration callback to pkg_install
Don't install files when @ignore was the previous line in the +CONTENTS file
In pkg_db_freebsd make sure the last directory and file are initilised.


Modified: trunk/src/pkg.c
===================================================================
--- trunk/src/pkg.c	2006-04-24 10:46:40 UTC (rev 103)
+++ trunk/src/pkg.c	2006-04-25 02:54:57 UTC (rev 104)
@@ -430,17 +430,17 @@
 int
 pkg_install(struct pkg *pkg, int reg, pkg_db_action * pkg_action, void *data,
 		pkg_db_chdir *db_chdir,	pkg_db_install_file *install_file,
-		pkg_db_exec *do_exec)
+		pkg_db_exec *do_exec, pkg_db_register *pkg_register)
 {
 	if (pkg == NULL || data == NULL || db_chdir == NULL ||
-	    install_file == NULL || do_exec == NULL)
+	    install_file == NULL || do_exec == NULL || pkg_register == NULL)
 		return -1;
 
 	if (pkg->pkg_install == NULL)
 		return -1;
 
 	return pkg->pkg_install(pkg, reg, pkg_action, data, db_chdir,
-	    install_file, do_exec);
+	    install_file, do_exec, pkg_register);
 }
 
 

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-24 10:46:40 UTC (rev 103)
+++ trunk/src/pkg_db_freebsd.c	2006-04-25 02:54:57 UTC (rev 104)
@@ -39,8 +39,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include <md5.h>
-
 #include "pkg.h"
 #include "pkg_db.h"
 #include "pkg_freebsd.h"
@@ -58,6 +56,7 @@
 	char directory[MAXPATHLEN];
 };
 #endif
+
 /*
  * State transition array for the head part of a +CONTENTS file.
  * p0 is the start state, p4 and p6 are the accepting states
@@ -87,6 +86,8 @@
 				struct pkg_file *);
 pkg_static int	freebsd_do_exec(struct pkg *, pkg_db_action *, void *,
 				const char *);
+pkg_static int	freebsd_register(struct pkg *, pkg_db_action *, void *,
+				struct pkg_file **);
 #ifdef DEAD
 pkg_static int			 freebsd_do_install(struct pkg_db *,
 				struct pkg *, int, pkg_db_action *);
@@ -188,12 +189,11 @@
 
 	/* Do the Install */
 	install_data.db = db;
-	install_data.fake = 0;
-	if (fake) {
-		install_data.fake = 1;
-	}
+	install_data.fake = fake;
+	install_data.last_file[0] = '\0';
+	install_data.directory[0] = '\0';
 	pkg_install(pkg, reg, pkg_action, &install_data, freebsd_do_chdir,
-	    freebsd_install_file, freebsd_do_exec);
+	    freebsd_install_file, freebsd_do_exec, freebsd_register);
 
 	/* Extract the +MTREE */
 	pkg_action(PKG_DB_INFO, "Running mtree for %s..", pkg_get_name(pkg));
@@ -208,10 +208,6 @@
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_post);
 
-	/* Record the package installation */
-	if (!fake && reg) {
-	}
-
 	/* Display contents of @display */
 #else
 	/* Get the control files from the package */
@@ -636,6 +632,37 @@
 	return 0;
 }
 
+static int
+freebsd_register(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
+		struct pkg_file **control)
+{
+	unsigned int pos;
+	struct pkg_install_data *install_data;
+	struct pkg_db *db;
+
+	assert(pkg != NULL);
+	assert(pkg_action != NULL);
+	assert(data != NULL);
+	assert(control != NULL);
+
+	install_data = data;
+	assert(install_data->db);
+	db = install_data->db;
+
+	pkg_action(PKG_DB_INFO,
+	    "Attempting to record package into " DB_LOCATION "/%s..",
+	    pkg_get_name(pkg));
+	for (pos = 0; control[pos] != NULL; pos++) {
+		freebsd_install_file(pkg, pkg_action, data, control[pos]);
+	}
+
+	/** @todo Register reverse dependency */
+	
+	pkg_action(PKG_DB_INFO, "Package %s registered in %s" DB_LOCATION "/%s",
+	    pkg_get_name(pkg), db->db_base, pkg_get_name(pkg));
+	return -1;
+}
+
 #else
 /**
  * @brief Internal function to to the correct thing for an \@cwd line
@@ -684,7 +711,7 @@
 }
 
 /**
- * @brief Builds a new cotents file
+ * @brief Builds a new contents file
  * @param contents The contents data to build the file from
  *
  * The file can be installed in /var/db/pkg/foo-1.2,3

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-24 10:46:40 UTC (rev 103)
+++ trunk/src/pkg_freebsd.c	2006-04-25 02:54:57 UTC (rev 104)
@@ -57,7 +57,8 @@
 pkg_static struct pkg_file	 *freebsd_get_next_file(struct pkg *);
 pkg_static int			  freebsd_install(struct pkg *, int,
 					pkg_db_action *, void *, pkg_db_chdir *,
-				       	pkg_db_install_file *, pkg_db_exec *);
+				       	pkg_db_install_file *, pkg_db_exec *,
+					pkg_db_register *);
 pkg_static struct pkg		**freebsd_get_deps(struct pkg *);
 pkg_static int			  freebsd_run_script(struct pkg *, pkg_script);
 pkg_static int			  freebsd_free(struct pkg *);
@@ -69,6 +70,8 @@
 pkg_static struct pkg_file	 *freebsd_get_next_entry(struct archive *);
 pkg_static int			  freebsd_parse_contents(
 					struct freebsd_package *);
+pkg_static struct pkg_file	 *freebsd_build_contents(
+					struct pkg_freebsd_contents *);
 
 typedef enum {
 	fpkg_unknown,
@@ -410,7 +413,7 @@
 static int
 freebsd_install(struct pkg *pkg, int reg, pkg_db_action *pkg_action, void *data,
 		pkg_db_chdir *db_chdir, pkg_db_install_file *install_file,
-		pkg_db_exec *do_exec)
+		pkg_db_exec *do_exec, pkg_db_register *pkg_register)
 {
 	int ret;
 	unsigned int pos;
@@ -423,6 +426,7 @@
 	assert(data != NULL);
 	assert(db_chdir != NULL);
 	assert(install_file != NULL);
+	assert(pkg_register != NULL);
 
 	ret = -1;
 	contents = NULL;
@@ -515,17 +519,16 @@
 				p = strchr(contents->lines[pos+1].data, ':');
 				p++;
 				if (pkg_checksum_md5(file, p) == 0) {
-					/** @todo Install the file */
-					install_file(pkg, pkg_action, data,
-					    file);
+					if (!ignore) {
+						install_file(pkg, pkg_action,
+						    data, file);
+					}
 				} else {
 					ret = -1;
 					goto exit;
 				}
 				pos++;
 			}
-//			if (ignore)
-//				printf(" (Ignored)");
 			break;
 		}
 		case PKG_LINE_EXEC:
@@ -536,14 +539,20 @@
 		}
 
 		default:
-			printf("%s", contents->lines[pos].line);
-			if (contents->lines[pos].data != NULL)
-				printf(" %s", contents->lines[pos].data);
-			if (ignore)
-				printf(" (Ignored)");
-			putchar('\n');
+			warnx("ERROR: Incorrect line in +CONTENTS file "
+			    "\"%s %s\"\n", contents->lines[pos].line,
+			    contents->lines[pos].data);
 		}
 	}
+	/* Switch the +CONTENTS file with one without @ignore'd files */
+	for (pos = 0; control[pos] != NULL; pos++)
+		if (!strcmp(control[pos]->filename, "+CONTENTS"))
+			break;
+	pkg_file_free(control[pos]);
+	control[pos] = freebsd_build_contents(contents);
+
+	pkg_register(pkg, pkg_action, data, control);
+
 exit:
 	if (contents != NULL)
 		pkg_freebsd_contents_free(contents);
@@ -983,5 +992,87 @@
 }
 
 /**
+ * @brief Builds a new contents file
+ * @param contents The contents data to build the file from
+ *
+ * The file can be installed in /var/db/pkg/foo-1.2,3
+ * @return The new contents file or NULL
+ */
+static struct pkg_file *
+freebsd_build_contents(struct pkg_freebsd_contents *contents)
+{
+	uint64_t size, used;
+	char *buffer, *ptr;
+	unsigned int i;
+
+	assert(contents != NULL);
+
+	used = 0;
+	size = 1024;
+	buffer = malloc(size);
+	ptr = buffer;
+	if (!buffer) {
+		return NULL;
+	}
+	for (i = 0; i < contents->line_count; i++) {
+		int line_len, data_len;
+
+		line_len = strlen(contents->lines[i].line);
+		data_len = 0;
+		if (contents->lines[i].line_type != PKG_LINE_FILE &&
+		    contents->lines[i].line_type != PKG_LINE_IGNORE) {
+			data_len = strlen(contents->lines[i].data);
+		}
+		/* if the line is @ignore we will ignore the 2 lines */
+		switch (contents->lines[i].line_type) {
+		case PKG_LINE_IGNORE:
+			i += 2;
+			break;
+		case PKG_LINE_CWD:
+			if (strcmp(contents->lines[i].data, ".")) {
+				if (used + line_len + data_len + 2 >= size) {
+					size += 1024;
+					buffer = realloc(buffer, size);
+					ptr = buffer + used;
+				}
+				sprintf(ptr, "%s %s\n",
+				    contents->lines[i].line,
+				    contents->lines[i].data);
+				used += line_len + data_len + 2;
+				ptr = buffer + used;
+			}
+		case PKG_LINE_MTREE:
+			break;
+		case PKG_LINE_FILE:
+			if (used + line_len + 1 >= size) {
+				size += 1024;
+				buffer = realloc(buffer, size);
+				ptr = buffer + used;
+			}
+			sprintf(ptr, "%s\n", contents->lines[i].line);
+			used += line_len + 1;
+			ptr = buffer + used;
+			break;
+		default:
+			if (used + line_len + data_len + 2 >= size) {
+				size += 1024;
+				buffer = realloc(buffer, size);
+				ptr = buffer + used;
+			}
+			sprintf(ptr, "%s %s\n", contents->lines[i].line,
+			    contents->lines[i].data);
+			used += line_len + data_len + 2;
+			ptr = buffer + used;
+			break;
+		}
+	}
+	/*
+	 * buffer now contains the data to write
+	 * to /var/db/pkg/foo-1.2.3/+CONTENTS
+	 */
+	return pkg_file_new_from_buffer("+CONTENTS", used, buffer, NULL);
+}
+
+/**
  * @}
  */

Modified: trunk/src/pkg_private.h
===================================================================
--- trunk/src/pkg_private.h	2006-04-24 10:46:40 UTC (rev 103)
+++ trunk/src/pkg_private.h	2006-04-25 02:54:57 UTC (rev 104)
@@ -83,9 +83,12 @@
 				void *, struct pkg_file *);
 typedef int		  pkg_db_exec(struct pkg *, pkg_db_action *, void *,
 				const char *);
+typedef int		  pkg_db_register(struct pkg *, pkg_db_action *, void *,
+				struct pkg_file **);
 typedef int	  	  pkg_install_callback(struct pkg*, int,
 				pkg_db_action *, void *, pkg_db_chdir *,
-				pkg_db_install_file *, pkg_db_exec *);
+				pkg_db_install_file *, pkg_db_exec *,
+				pkg_db_register *);
 typedef struct pkg_file	 *pkg_get_next_file_callback(struct pkg *);
 typedef int		  pkg_run_script_callback(struct pkg *, pkg_script);
 int			  pkg_add_callbacks_install(struct pkg *,
@@ -94,7 +97,7 @@
 				pkg_run_script_callback *);
 int			  pkg_install(struct pkg *, int, pkg_db_action *,
 				void *, pkg_db_chdir *, pkg_db_install_file *,
-				pkg_db_exec *);
+				pkg_db_exec *, pkg_db_register *);
 
 struct pkg {
 	void	*data;



From zxombie at berlios.de  Tue Apr 25 05:38:09 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 25 Apr 2006 05:38:09 +0200
Subject: [Libpkg-svn] r105 - trunk/src
Message-ID: <200604250338.k3P3c976000209@sheep.berlios.de>

Author: zxombie
Date: 2006-04-25 05:37:40 +0200 (Tue, 25 Apr 2006)
New Revision: 105

Modified:
   trunk/src/pkg_db_freebsd.c
Log:
Install files and fix the checks to se if this is a fake run


Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-25 02:54:57 UTC (rev 104)
+++ trunk/src/pkg_db_freebsd.c	2006-04-25 03:37:40 UTC (rev 105)
@@ -577,16 +577,16 @@
 	if (strcmp(dir, ".") == 0) {
 		snprintf(install_data->directory, MAXPATHLEN,
 		    "%s" DB_LOCATION "/%s", db->db_base, pkg_get_name(pkg));
-		if (install_data->fake != 0)
-			pkg_dir_build(install_data->directory);
 	} else {
 		snprintf(install_data->directory, MAXPATHLEN, "%s/%s",
 		    db->db_base, dir);
 	}
 
 	pkg_action(PKG_DB_PACKAGE, "CWD to %s", install_data->directory);
-	if (install_data->fake != 0)
+	if (!install_data->fake) {
+		pkg_dir_build(install_data->directory);
 		return chdir(install_data->directory);
+	}
 
 	return 0;
 }
@@ -602,10 +602,15 @@
 	assert(file != NULL);
 
 	install_data = data;
+
 	snprintf(install_data->last_file, FILENAME_MAX, "%s",
 	    pkg_file_get_name(file));
-	printf("%s\n", pkg_file_get_name(file));
-	return -1;
+
+	pkg_action(PKG_DB_PACKAGE, "%s/%s", install_data->directory,
+	    pkg_file_get_name(file));
+	if (!install_data->fake)
+		return pkg_file_write(file);
+	return 0;
 }
 
 static int



From zxombie at berlios.de  Tue Apr 25 07:07:50 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 25 Apr 2006 07:07:50 +0200
Subject: [Libpkg-svn] r106 - trunk/src
Message-ID: <200604250507.k3P57one004262@sheep.berlios.de>

Author: zxombie
Date: 2006-04-25 07:07:47 +0200 (Tue, 25 Apr 2006)
New Revision: 106

Modified:
   trunk/src/pkg_db_freebsd.c
Log:
Make sure we exit in the same directory we entered in when installing packages
Fix the check for fake installations when executing scripts


Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-25 03:37:40 UTC (rev 105)
+++ trunk/src/pkg_db_freebsd.c	2006-04-25 05:07:47 UTC (rev 106)
@@ -160,6 +160,7 @@
 	unsigned int pos, line;
 #else
 	struct pkg_install_data install_data;
+	char cwd[MAXPATHLEN];
 #endif
 
 	assert(db != NULL);
@@ -167,6 +168,9 @@
 	assert(pkg_action != NULL);
 
 #ifdef NEW_DB
+	if (getwd(cwd) == NULL)
+		return -1;
+
 	pkg_action(PKG_DB_PACKAGE, "Package name is %s", pkg_get_name(pkg));
 
 	/* Run +REQUIRE */
@@ -209,6 +213,8 @@
 		pkg_run_script(pkg, pkg_script_post);
 
 	/* Display contents of @display */
+
+	chdir(cwd);
 #else
 	/* Get the control files from the package */
 	control = pkg_get_control_files(pkg);
@@ -631,7 +637,7 @@
 	    install_data->last_file);
 
 	pkg_action(PKG_DB_PACKAGE, "execute '%s'", the_cmd);
-	if (install_data->fake != 0)
+	if (!install_data->fake)
 		return pkg_exec(the_cmd);
 
 	return 0;



From zxombie at berlios.de  Tue Apr 25 10:39:54 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 25 Apr 2006 10:39:54 +0200
Subject: [Libpkg-svn] r107 - trunk/src
Message-ID: <200604250839.k3P8dsEI015107@sheep.berlios.de>

Author: zxombie
Date: 2006-04-25 10:39:49 +0200 (Tue, 25 Apr 2006)
New Revision: 107

Modified:
   trunk/src/pkg_db_freebsd.c
Log:
Register the reverse dependency of a package


Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-25 05:07:47 UTC (rev 106)
+++ trunk/src/pkg_db_freebsd.c	2006-04-25 08:39:49 UTC (rev 107)
@@ -650,6 +650,7 @@
 	unsigned int pos;
 	struct pkg_install_data *install_data;
 	struct pkg_db *db;
+	struct pkg **deps;
 
 	assert(pkg != NULL);
 	assert(pkg_action != NULL);
@@ -667,7 +668,24 @@
 		freebsd_install_file(pkg, pkg_action, data, control[pos]);
 	}
 
-	/** @todo Register reverse dependency */
+	/* Register reverse dependency */
+	deps = pkg_get_dependencies(pkg);
+	for (pos=0; deps[pos] != NULL; pos++) {
+		char required_by[FILENAME_MAX];
+		const char *name;
+		FILE *fd;
+
+		snprintf(required_by, FILENAME_MAX, "%s" DB_LOCATION
+		    "/%s/+REQUIRED_BY", db->db_base, pkg_get_name(deps[pos]));
+
+		/** @todo Make pkg_file work to properly to create the file */
+		fd = fopen(required_by, "a");
+		name = pkg_get_name(pkg);
+		fwrite(name, strlen(name), 1, fd);
+		fwrite("\n", 1, 1, fd);
+		fclose(fd);
+	}
+	pkg_list_free(deps);
 	
 	pkg_action(PKG_DB_INFO, "Package %s registered in %s" DB_LOCATION "/%s",
 	    pkg_get_name(pkg), db->db_base, pkg_get_name(pkg));



From zxombie at berlios.de  Tue Apr 25 10:51:15 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 25 Apr 2006 10:51:15 +0200
Subject: [Libpkg-svn] r108 - trunk/src
Message-ID: <200604250851.k3P8pFBD028138@sheep.berlios.de>

Author: zxombie
Date: 2006-04-25 10:51:12 +0200 (Tue, 25 Apr 2006)
New Revision: 108

Modified:
   trunk/src/pkg_freebsd.c
Log:
Ignore @conflicts lines when installing
Fix freebsd_get_deps return an array with only a NULL when a package has no dependencies
Don't mutilate the +CONTENTS file before installing it. Cvs pkg_add dosn't so neither should we


Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-25 08:39:49 UTC (rev 107)
+++ trunk/src/pkg_freebsd.c	2006-04-25 08:51:12 UTC (rev 108)
@@ -70,8 +70,6 @@
 pkg_static struct pkg_file	 *freebsd_get_next_entry(struct archive *);
 pkg_static int			  freebsd_parse_contents(
 					struct freebsd_package *);
-pkg_static struct pkg_file	 *freebsd_build_contents(
-					struct pkg_freebsd_contents *);
 
 typedef enum {
 	fpkg_unknown,
@@ -469,6 +467,7 @@
 		case PKG_LINE_DIRRM:
 		case PKG_LINE_MTREE:
 		case PKG_LINE_PKGDEP:
+		case PKG_LINE_CONFLICTS:
 			break;
 		case PKG_LINE_NAME:
 			/* Check the name is the same as the packages name */
@@ -544,13 +543,7 @@
 			    contents->lines[pos].data);
 		}
 	}
-	/* Switch the +CONTENTS file with one without @ignore'd files */
-	for (pos = 0; control[pos] != NULL; pos++)
-		if (!strcmp(control[pos]->filename, "+CONTENTS"))
-			break;
-	pkg_file_free(control[pos]);
-	control[pos] = freebsd_build_contents(contents);
-
+	/* Register the package */
 	pkg_register(pkg, pkg_action, data, control);
 
 exit:
@@ -623,6 +616,7 @@
 	pkgs = malloc(pkg_size);
 	if (pkgs == NULL)
 		return NULL;
+	pkgs[0] = NULL;
 
 	for (line = 0; line < fpkg->contents->line_count; line++) {
 		if (fpkg->contents->lines[line].line_type == PKG_LINE_PKGDEP) {
@@ -992,87 +986,5 @@
 }
 
 /**
- * @brief Builds a new contents file
- * @param contents The contents data to build the file from
- *
- * The file can be installed in /var/db/pkg/foo-1.2,3
- * @return The new contents file or NULL
- */
-static struct pkg_file *
-freebsd_build_contents(struct pkg_freebsd_contents *contents)
-{
-	uint64_t size, used;
-	char *buffer, *ptr;
-	unsigned int i;
-
-	assert(contents != NULL);
-
-	used = 0;
-	size = 1024;
-	buffer = malloc(size);
-	ptr = buffer;
-	if (!buffer) {
-		return NULL;
-	}
-	for (i = 0; i < contents->line_count; i++) {
-		int line_len, data_len;
-
-		line_len = strlen(contents->lines[i].line);
-		data_len = 0;
-		if (contents->lines[i].line_type != PKG_LINE_FILE &&
-		    contents->lines[i].line_type != PKG_LINE_IGNORE) {
-			data_len = strlen(contents->lines[i].data);
-		}
-		/* if the line is @ignore we will ignore the 2 lines */
-		switch (contents->lines[i].line_type) {
-		case PKG_LINE_IGNORE:
-			i += 2;
-			break;
-		case PKG_LINE_CWD:
-			if (strcmp(contents->lines[i].data, ".")) {
-				if (used + line_len + data_len + 2 >= size) {
-					size += 1024;
-					buffer = realloc(buffer, size);
-					ptr = buffer + used;
-				}
-				sprintf(ptr, "%s %s\n",
-				    contents->lines[i].line,
-				    contents->lines[i].data);
-				used += line_len + data_len + 2;
-				ptr = buffer + used;
-			}
-		case PKG_LINE_MTREE:
-			break;
-		case PKG_LINE_FILE:
-			if (used + line_len + 1 >= size) {
-				size += 1024;
-				buffer = realloc(buffer, size);
-				ptr = buffer + used;
-			}
-			sprintf(ptr, "%s\n", contents->lines[i].line);
-			used += line_len + 1;
-			ptr = buffer + used;
-			break;
-		default:
-			if (used + line_len + data_len + 2 >= size) {
-				size += 1024;
-				buffer = realloc(buffer, size);
-				ptr = buffer + used;
-			}
-			sprintf(ptr, "%s %s\n", contents->lines[i].line,
-			    contents->lines[i].data);
-			used += line_len + data_len + 2;
-			ptr = buffer + used;
-			break;
-		}
-	}
-	/*
-	 * buffer now contains the data to write
-	 * to /var/db/pkg/foo-1.2.3/+CONTENTS
-	 */
-	return pkg_file_new_from_buffer("+CONTENTS", used, buffer, NULL);
-}
-
-/**
  * @}
  */



From zxombie at berlios.de  Tue Apr 25 11:20:42 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Tue, 25 Apr 2006 11:20:42 +0200
Subject: [Libpkg-svn] r109 - trunk/src
Message-ID: <200604250920.k3P9KgfQ016795@sheep.berlios.de>

Author: zxombie
Date: 2006-04-25 11:20:40 +0200 (Tue, 25 Apr 2006)
New Revision: 109

Modified:
   trunk/src/pkg_db_freebsd.c
Log:
Remove the old FreeBSD package installation backend


Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-25 08:51:12 UTC (rev 108)
+++ trunk/src/pkg_db_freebsd.c	2006-04-25 09:20:40 UTC (rev 109)
@@ -48,14 +48,12 @@
 
 #define DB_LOCATION	"/var/db/pkg"
 
-#ifdef NEW_DB
 struct pkg_install_data {
 	int fake;
 	struct pkg_db *db;
 	char last_file[FILENAME_MAX];
 	char directory[MAXPATHLEN];
 };
-#endif
 
 /*
  * State transition array for the head part of a +CONTENTS file.
@@ -78,8 +76,7 @@
 				pkg_db_match *, const void *);
 pkg_static struct pkg	 *freebsd_get_package(struct pkg_db *, const char *);	
 
-/* Internal */
-#ifdef NEW_DB
+/* pkg_install callbacks */
 pkg_static int	freebsd_do_chdir(struct pkg *, pkg_db_action *, void *,
 				const char *);
 pkg_static int	freebsd_install_file(struct pkg *, pkg_db_action *, void *,
@@ -88,18 +85,7 @@
 				const char *);
 pkg_static int	freebsd_register(struct pkg *, pkg_db_action *, void *,
 				struct pkg_file **);
-#ifdef DEAD
-pkg_static int			 freebsd_do_install(struct pkg_db *,
-				struct pkg *, int, pkg_db_action *);
-#endif
-#else
-pkg_static struct pkg_file	*freebsd_build_contents(
-				struct pkg_freebsd_contents *);
-pkg_static int			 freebsd_do_cwd(struct pkg_db *, struct pkg *,
-				char *, int);
-pkg_static int			 freebsd_check_contents(struct pkg_db *,
-				struct pkg_freebsd_contents *, int);
-#endif
+/* Internal */
 pkg_static void			 freebsd_format_cmd(char *, int, const char *,
 				const char *, const char *);
 
@@ -150,24 +136,13 @@
 freebsd_install_pkg_action(struct pkg_db *db, struct pkg *pkg, int reg,
     int fake, pkg_db_action *pkg_action)
 {
-#ifndef NEW_DB
-	struct pkg_file	*contents_file;
-	struct pkg_file **control;
-	struct pkg_freebsd_contents *contents;
-	char *cwd;
-	char *directory, *last_file;
-	int i;
-	unsigned int pos, line;
-#else
 	struct pkg_install_data install_data;
 	char cwd[MAXPATHLEN];
-#endif
 
 	assert(db != NULL);
 	assert(pkg != NULL);
 	assert(pkg_action != NULL);
 
-#ifdef NEW_DB
 	if (getwd(cwd) == NULL)
 		return -1;
 
@@ -212,230 +187,9 @@
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_post);
 
-	/* Display contents of @display */
+	/** @todo Display contents of @display */
 
 	chdir(cwd);
-#else
-	/* Get the control files from the package */
-	control = pkg_get_control_files(pkg);
-	if (!control) {
-		return -1;
-	}
-
-	/* Find the +CONTENTS file in the control files */
-	for (pos = 0; control[pos] != NULL; pos++)
-		if (!strcmp(control[pos]->filename, "+CONTENTS"))
-			break;
-	contents_file = control[pos];
-	if (!contents_file) {
-		return -1;
-	}
-
-	contents = pkg_freebsd_contents_new(pkg_file_get(contents_file));
-	if (!contents) {
-		return -1;
-	}
-
-	pkg_action(PKG_DB_PACKAGE, "Package name is %s", pkg_get_name(pkg));
-
-	cwd = getcwd(NULL, 0);
-	if (!cwd) {
-		pkg_freebsd_contents_free(contents);
-		return -1;
-	}
-
-	i = freebsd_check_contents(db, contents, fake);
-	if (i < 0) {
-		pkg_freebsd_contents_free(contents);
-		chdir(cwd);
-		free(cwd);
-		return -1;
-	} else
-		line = i;
-
-	/* directory is used int the processing of +CONTENTS files */
-	directory = getcwd(NULL, 0);
-	pkg_set_prefix(pkg, directory);
-	last_file = NULL;
-
-	/** @todo pkg_action the pre script */
-	pkg_run_script(pkg, pkg_script_pre);
-
-	/* Read through the contents file and install the package */
-	for (; line < contents->line_count; line++) {
-		switch (contents->lines[line].line_type) {
-		case PKG_LINE_COMMENT:
-		case PKG_LINE_UNEXEC:
-		case PKG_LINE_DIRRM:
-		case PKG_LINE_MTREE:
-		case PKG_LINE_IGNORE:
-			break;
-		case PKG_LINE_CWD:
-			/* Change to the correct directory */
-			if (!fake) {
-				if (reg || (!reg &&
-				    strcmp(contents->lines[line].data,".")!=0)){
-					free(directory);
-					if (freebsd_do_cwd(db, pkg,
-					    contents->lines[line].data, fake) != 0) {
-						chdir(cwd);
-						free(cwd);
-						pkg_freebsd_contents_free(contents);
-						return -1;
-					}
-					directory = getcwd(NULL, 0);
-				}
-			}
-			pkg_action(PKG_DB_PACKAGE, "CWD to %s",
-			    contents->lines[line].data);
-			break;
-		case PKG_LINE_EXEC: {
-			char cmd[FILENAME_MAX];
-			freebsd_format_cmd(cmd, FILENAME_MAX,
-			    contents->lines[line].data, directory, last_file);
-			if (!fake)
-				pkg_exec(cmd);
-			pkg_action(PKG_DB_PACKAGE, "execute '%s'", cmd);
-			break;
-		}
-		case PKG_LINE_FILE: {
-			/* Install a file to the correct directory */
-
-			struct pkg_file *file;
-			char *contents_sum;
-			int ret;
-
-			/* Check the contents file is correctly formated */
-			if (contents->lines[line+1].line_type !=
-			    PKG_LINE_COMMENT) {
-				chdir(cwd);
-				free(cwd);
-				free(directory);
-				pkg_freebsd_contents_free(contents);
-				return -1;
-			} else if (strncmp("MD5:", contents->lines[line+1].data,
-			    4)) {
-				chdir(cwd);
-				free(cwd);
-				free(directory);
-				pkg_freebsd_contents_free(contents);
-				return -1;
-			}
-
-			/* Read the file to install */
-			if (contents->lines[line].line[0] == '+') {
-				/*
-				 * + Files are not fetched with
-				 * pkg_get_next_file
-				 */
-				for (pos = 0; control[pos] != NULL;
-				    pos++) {
-					if (!strcmp(control[pos]->filename,
-					    contents->lines[line].line))
-						break;
-				}
-				file = control[pos];
-			} else {
-				file = pkg_get_next_file(pkg);
-
-				/* Check the file name is correct */
-				if (strcmp(file->filename,
-				    contents->lines[line].line)) {
-					chdir(cwd);
-					free(cwd);
-					free(directory);
-					pkg_file_free(file);
-					pkg_freebsd_contents_free(contents);
-					return -1;
-				}
-				pkg_action(PKG_DB_PACKAGE, "%s/%s", directory,
-				    pkg_file_get_name(file));
-			}
-
-			contents_sum = strchr(contents->lines[line+1].data,
-			    ':');
-			contents_sum++;
-			if (S_ISREG(file->stat->st_mode) &&
-			    pkg_checksum_md5(file, contents_sum) != 0) {
-				chdir(cwd);
-				free(cwd);
-				free(directory);
-				pkg_file_free(file);
-				pkg_freebsd_contents_free(contents);
-				return -1;
-			}
-
-			/* Install the file */
-			if (!fake) {
-				if (reg ||
-				    (!reg && pkg_file_get_name(file)[0] !='+')){
-					ret = pkg_file_write(file);
-					if (ret != 0) {
-						chdir(cwd);
-						free(cwd);
-						free(directory);
-						pkg_file_free(file);
-						pkg_freebsd_contents_free(contents);
-						return -1;
-					}
-				}
-			}
-
-			/* Remember the name if there is an "@exec" line next */
-			if (last_file)
-				free(last_file);
-			last_file = strdup(file->filename);
-
-			if (contents->lines[line].line[0] != '+')
-				pkg_file_free(file);
-
-			line++;
-			break;
-		}
-		default:
-			fprintf(stderr, "ERROR: Incorrect line in "
-			    "+CONTENTS file \"%s %s\"\n",
-			    contents->lines[line].line,
-			    contents->lines[line].data);
-			break;
-		}
-	}
-
-
-	pkg_action(PKG_DB_INFO, "Running mtree for %s..", pkg_get_name(pkg));
-
-	if (!fake)
-		pkg_run_script(pkg, pkg_script_mtree);
-
-	/** @todo pkg_action the post script */
-	pkg_run_script(pkg, pkg_script_post);
-
-	if (reg) {
-		pkg_action(PKG_DB_INFO,
-		    "Attempting to record package into " DB_LOCATION "/%s..",
-		    pkg_get_name(pkg));
-
-		/* Create the new contents file */
-		if (!fake) {
-			contents_file = freebsd_build_contents(contents);
-			pkg_file_write(contents_file);
-			pkg_file_free(contents_file);
-		}
-		/** @todo Register the reverse dependencies */
-		pkg_action(PKG_DB_INFO,
-		    "Package %s registered in " DB_LOCATION "/%s",
-		    pkg_get_name(pkg), pkg_get_name(pkg));
-	}
-
-	free(directory);
-	if (last_file != NULL)
-		free(last_file);
-	chdir(cwd);
-	free(cwd);
-
-	pkg_freebsd_contents_free(contents);
-
-#endif
 	return 0;
 }
 
@@ -562,7 +316,6 @@
  * @{
  */
 
-#ifdef NEW_DB
 static int
 freebsd_do_chdir(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
 		const char *dir)
@@ -692,136 +445,8 @@
 	return -1;
 }
 
-#else
+#ifdef DEAD
 /**
- * @brief Internal function to to the correct thing for an \@cwd line
- * @return 0 if successful or -1 on error
- */
-static int
-freebsd_do_cwd(struct pkg_db *db, struct pkg *pkg, char *ndir, int fake) {
-	char *dir;
-
-	assert(db != NULL);
-	assert(ndir != NULL);
-
-	/*
-	 * If the dir is . it should really
-	 * be the package database dir
-	 */
-	if (ndir[0] == '.' &&
-	    ndir[1] == '\0') {
-		assert(pkg != NULL); /* pkg is only needed to chdir to . */
-
-		/* When faking it don't create the database dir */
-		if (fake)
-			return 0;
-
-		asprintf(&dir, "%s/var/db/pkg/%s", db->db_base,
-		    pkg_get_name(pkg));
-		if (!dir) {
-			return -1;
-		}
-		pkg_dir_build(dir);
-	} else {
-		/* Set dir to the correct location */
-		asprintf(&dir, "%s/%s", db->db_base, ndir);
-		if (!dir) {
-			return -1;
-		}
-	}
-	if (chdir(dir) == -1) {
-		free(dir);
-		return -1;
-	}
-
-	free(dir);
-
-	return 0;
-}
-
-/**
- * @brief Builds a new contents file
- * @param contents The contents data to build the file from
- *
- * The file can be installed in /var/db/pkg/foo-1.2,3
- * @return The new contents file or NULL
- */
-static struct pkg_file *
-freebsd_build_contents(struct pkg_freebsd_contents *contents)
-{
-	uint64_t size, used;
-	char *buffer, *ptr;
-	unsigned int i;
-
-	assert(contents != NULL);
-
-	used = 0;
-	size = 1024;
-	buffer = malloc(size);
-	ptr = buffer;
-	if (!buffer) {
-		return NULL;
-	}
-	for (i = 0; i < contents->line_count; i++) {
-		int line_len, data_len;
-
-		line_len = strlen(contents->lines[i].line);
-		data_len = 0;
-		if (contents->lines[i].line_type != PKG_LINE_FILE &&
-		    contents->lines[i].line_type != PKG_LINE_IGNORE) {
-			data_len = strlen(contents->lines[i].data);
-		}
-		/* if the line is @ignore we will ignore the 2 lines */
-		switch (contents->lines[i].line_type) {
-		case PKG_LINE_IGNORE:
-			i += 2;
-			break;
-		case PKG_LINE_CWD:
-			if (strcmp(contents->lines[i].data, ".")) {
-				if (used + line_len + data_len + 2 >= size) {
-					size += 1024;
-					buffer = realloc(buffer, size);
-					ptr = buffer + used;
-				}
-				sprintf(ptr, "%s %s\n",
-				    contents->lines[i].line,
-				    contents->lines[i].data);
-				used += line_len + data_len + 2;
-				ptr = buffer + used;
-			}
-		case PKG_LINE_MTREE:
-			break;
-		case PKG_LINE_FILE:
-			if (used + line_len + 1 >= size) {
-				size += 1024;
-				buffer = realloc(buffer, size);
-				ptr = buffer + used;
-			}
-			sprintf(ptr, "%s\n", contents->lines[i].line);
-			used += line_len + 1;
-			ptr = buffer + used;
-			break;
-		default:
-			if (used + line_len + data_len + 2 >= size) {
-				size += 1024;
-				buffer = realloc(buffer, size);
-				ptr = buffer + used;
-			}
-			sprintf(ptr, "%s %s\n", contents->lines[i].line,
-			    contents->lines[i].data);
-			used += line_len + data_len + 2;
-			ptr = buffer + used;
-			break;
-		}
-	}
-	/*
-	 * buffer now contains the data to write
-	 * to /var/db/pkg/foo-1.2.3/+CONTENTS
-	 */
-	return pkg_file_new_from_buffer("+CONTENTS", used, buffer, NULL);
-}
-
-/**
  * @brief Checks the start of a contents file
  * @return The number of lines to skip to get to the first file or -1 on error
  */



From zxombie at berlios.de  Wed Apr 26 06:14:02 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 26 Apr 2006 06:14:02 +0200
Subject: [Libpkg-svn] r110 - trunk/src
Message-ID: <200604260414.k3Q4E2Vi028853@sheep.berlios.de>

Author: zxombie
Date: 2006-04-26 06:13:56 +0200 (Wed, 26 Apr 2006)
New Revision: 110

Modified:
   trunk/src/pkg.c
   trunk/src/pkg_db_freebsd.c
   trunk/src/pkg_freebsd.c
Log:
Reduce the warnings from Doxygen


Modified: trunk/src/pkg.c
===================================================================
--- trunk/src/pkg.c	2006-04-25 09:20:40 UTC (rev 109)
+++ trunk/src/pkg.c	2006-04-26 04:13:56 UTC (rev 110)
@@ -51,7 +51,7 @@
  * @param control_file A callback to be used by pkg_get_control_file()
  * @param get_deps A callback to be used by pkg_get_dependencies()
  * @param free_pkg A call back to be used by pkg_free()
- * @return A new #pkg object, or NULL on error
+ * @return A new pkg object, or NULL on error
  */
 struct pkg *
 pkg_new(const char *pkg_name,
@@ -144,6 +144,7 @@
 /**
  * @brief Internal function to add callbacks that are used when a package is installed
  * @param pkg The package returned by pkg_new()
+ * @param install A callback to be used by pkg_install()
  * @param next_file A callback to be used by pkg_get_next_file()
  * @param run_script A callback to be used by pkg_run_script()
  * @return 0 on success, -1 on error.
@@ -173,13 +174,14 @@
  * 
  * These are the publicly availiable package manipulation functions.
  *
- * Most functions take a pointer to struct #pkg as the first argument.
+ * Most functions take a pointer to struct pkg as the first argument.
  * This is the package that is currently being worked on.
  * @{
  */
 
 /**
  * @brief Creates an empty package with no callbacks
+ * @param pkg_name The name of the package
  *
  * This is the simplest package constructor.
  * It is used to create a package with just a name associated with it.
@@ -212,7 +214,7 @@
 
 /**
  * @brief Sets the location to install the package to
- * @param pkg The package to install
+ * @param pkg The package
  * @param prefix The location in the filesystem to install the package pkg to
  * 
  * If the prefix is set and malloc fails the old prefix is kept.
@@ -243,6 +245,7 @@
 
 /**
  * @brief Returns the prefix or NULL
+ * @param pkg The package
  * @return the prefix or NULL if it hasn't been set
  */
 const char *
@@ -256,6 +259,7 @@
 
 /**
  * @brief Gets the control files from a given package
+ * @param pkg The package
  * 
  * @return A null-terminated array of pkg_file's contining the packages control files
  */
@@ -275,6 +279,7 @@
 
 /**
  * @brief Gets a given control file from a package
+ * @param pkg The package
  * @param pkg_name The name of the file to return
  * @return The control file with the name pkg_name
  */
@@ -292,6 +297,7 @@
 
 /**
  * @brief Gets all the dependencies for a given package
+ * @param pkg The package
  *
  * This retrieves an array of packages that the named package depends on.
  * @return A NULL terminated array of packages or NULL;
@@ -309,6 +315,7 @@
 
 /**
  * @brief Gets the name of a package
+ * @param pkg The package
  *
  * @return a sting containing the package name. Do not free this.
  */
@@ -322,6 +329,7 @@
 
 /**
  * @brief Gets the next file in a package.
+ * @param pkg The package
  *
  * Ths is used during the instillation of a package to iterate over
  * all files to be installed in a package
@@ -343,6 +351,7 @@
 
 /**
  * @brief Gets a packages origin
+ * @param pkg The package
  *
  * This is used to get the package origin from packages that record it.
  * Not all package formats have an origin.
@@ -362,6 +371,7 @@
 
 /**
  * @brief Get the package format version
+ * @param pkg The package
  *
  * This retrieves a free form string containing the package format's version.
  * It is intended to be shown to the user rather than be processed.
@@ -381,6 +391,8 @@
 
 /**
  * @brief Runs the named script from the package
+ * @param pkg The package
+ * @param script The script to run
  * @return The return value of the script, or -1
  */
 int
@@ -397,6 +409,8 @@
 
 /**
  * @brief Adds a dependency to a given package
+ * @param pkg The package
+ * @param depend The package to depend on
  * @return 0 on success, -1 on error.
  */
 int
@@ -413,6 +427,8 @@
 
 /**
  * @brief Adds a file to a given package
+ * @param pkg The package
+ * @param file The file to add to the package
  * @return 0 on success, -1 on error.
  */
 int
@@ -427,6 +443,26 @@
 	return -1;
 }
 
+/**
+ * @brief Installs a package using the given callbacks
+ * @param pkg The package to install
+ * @param reg If true the package will be registered
+ * @param pkg_action A callback to display a message to the user
+ * @param data A pointer to pass to pkg_db_* callbacks
+ * @param db_chdir A callback to change to a new directory
+ * @param install_file A callback to install a file in a database
+ * @param do_exec A callback to execute a script
+ * @param pkg_register A callback to register a package
+ *
+ * pkg_install() is an internal function to the library.
+ * It is designed to seperate the knowledge of packages and
+ * package databases apart.
+ * The package database now only knows how to install the
+ * parts of a package it is given, not the internals of a
+ * given package.
+ * 
+ * @return 0 on success or -1 or error
+ */
 int
 pkg_install(struct pkg *pkg, int reg, pkg_db_action * pkg_action, void *data,
 		pkg_db_chdir *db_chdir,	pkg_db_install_file *install_file,
@@ -446,6 +482,7 @@
 
 /**
  * @brief Frees a NULL terminated array of packages
+ * @param pkgs A NULL terminated array of pkg objects
  *
  * This is to be used to free the arrays generated by
  * pkg_get_dependencies()
@@ -469,6 +506,7 @@
 
 /**
  * @brief Frees a given package
+ * @param pkg The package to free
  * @return 0 on success, -1 on error.
  */
 int

Modified: trunk/src/pkg_db_freebsd.c
===================================================================
--- trunk/src/pkg_db_freebsd.c	2006-04-25 09:20:40 UTC (rev 109)
+++ trunk/src/pkg_db_freebsd.c	2006-04-26 04:13:56 UTC (rev 110)
@@ -124,6 +124,7 @@
  * @brief Callback for pkg_db_install_pkg_action()
  * @param db The database to install to
  * @param pkg The package to install
+ * @param reg If true register the package in the database
  * @param pkg_action A function to call when an action takes place
  * @param fake Should we actually install the package or just report what would have happened
  * @todo Run mtree
@@ -187,7 +188,7 @@
 	if (!fake)
 		pkg_run_script(pkg, pkg_script_post);
 
-	/** @todo Display contents of @display */
+	/** @todo Display contents of \@display */
 
 	chdir(cwd);
 	return 0;
@@ -316,6 +317,11 @@
  * @{
  */
 
+/**
+ * @brief The db_chdir callback of pkg_install() for the FreeBSD package
+ *     database
+ * @return 0 on success or -1 on error
+ */
 static int
 freebsd_do_chdir(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
 		const char *dir)
@@ -350,6 +356,11 @@
 	return 0;
 }
 
+/**
+ * @brief The install_file callback of pkg_install() for the FreeBSD package
+ *     database
+ * @return 0 on success or -1 on error
+ */
 static int
 freebsd_install_file(struct pkg *pkg, pkg_db_action *pkg_action __unused,
 		void *data, struct pkg_file *file)
@@ -372,6 +383,11 @@
 	return 0;
 }
 
+/**
+ * @brief The do_chdir callback of pkg_install() for the FreeBSD package
+ *     database
+ * @return 0 on success or -1 on error
+ */
 static int
 freebsd_do_exec(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
 		const char *cmd)
@@ -396,6 +412,11 @@
 	return 0;
 }
 
+/**
+ * @brief The pkg_register callback of pkg_install() for the FreeBSD package
+ *     database
+ * @return 0 on success or -1 on error
+ */
 static int
 freebsd_register(struct pkg *pkg, pkg_db_action *pkg_action, void *data,
 		struct pkg_file **control)

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-25 09:20:40 UTC (rev 109)
+++ trunk/src/pkg_freebsd.c	2006-04-26 04:13:56 UTC (rev 110)
@@ -208,6 +208,7 @@
 	return pkg;
 }
 
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
 /**
  * @brief Creates an empty FreeBSD package to add files to
  * @param pkg_name The name of the package
@@ -235,6 +236,7 @@
 	assert(0);
 	return NULL;
 }
+#endif
 
 /**
  * @}
@@ -408,6 +410,10 @@
 	return NULL;
 }
 
+/**
+ * @brief Callback for pkg_install()
+ * @return 0 on success or -1 on error
+ */
 static int
 freebsd_install(struct pkg *pkg, int reg, pkg_db_action *pkg_action, void *data,
 		pkg_db_chdir *db_chdir, pkg_db_install_file *install_file,
@@ -808,6 +814,9 @@
 	return fpkg;
 }
 
+/**
+ * @brief Frees a file list
+ */
 #define FREE_CONTENTS(c) \
 	{ \
 		int i; \



From zxombie at berlios.de  Wed Apr 26 10:48:51 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 26 Apr 2006 10:48:51 +0200
Subject: [Libpkg-svn] r111 - trunk
Message-ID: <200604260848.k3Q8mpDd031810@sheep.berlios.de>

Author: zxombie
Date: 2006-04-26 10:48:43 +0200 (Wed, 26 Apr 2006)
New Revision: 111

Added:
   trunk/Doxyfile
Modified:
   trunk/Makefile
Log:
Generate the documentation


Added: trunk/Doxyfile
===================================================================
--- trunk/Doxyfile	2006-04-26 04:13:56 UTC (rev 110)
+++ trunk/Doxyfile	2006-04-26 08:48:43 UTC (rev 111)
@@ -0,0 +1,1237 @@
+# Doxyfile 1.4.6
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = libpkg
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 0.1
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = doc
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
+# Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# This tag can be used to specify the encoding used in the generated output. 
+# The encoding is not always determined by the language that is chosen, 
+# but also whether or not the output is meant for Windows or non-Windows users. 
+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
+# forces the Windows encoding (this is the default for the Windows binary), 
+# whereas setting the tag to NO uses a Unix-style encoding (the default for 
+# all platforms other than Windows).
+
+USE_WINDOWS_ENCODING   = NO
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to 
+# include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = NO
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = YES
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = src
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py
+
+FILE_PATTERNS          = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = *_private.h
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = DOXYGEN_SHOULD_SKIP_THIS
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH    = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT   = 1024
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that a graph may be further truncated if the graph's 
+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
+# the graph is not depth-constrained.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-26 04:13:56 UTC (rev 110)
+++ trunk/Makefile	2006-04-26 08:48:43 UTC (rev 111)
@@ -1,3 +1,6 @@
 SUBDIR=src tools
 
+docs:
+	/usr/local/bin/doxygen Doxyfile
+
 .include <bsd.subdir.mk>



From zxombie at berlios.de  Wed Apr 26 11:21:50 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 26 Apr 2006 11:21:50 +0200
Subject: [Libpkg-svn] r112 - www
Message-ID: <200604260921.k3Q9Lo63006866@sheep.berlios.de>

Author: zxombie
Date: 2006-04-26 11:21:50 +0200 (Wed, 26 Apr 2006)
New Revision: 112

Modified:
   www/nav.xml
Log:
Add a link to the automaticly generated documentetion


Modified: www/nav.xml
===================================================================
--- www/nav.xml	2006-04-26 08:48:43 UTC (rev 111)
+++ www/nav.xml	2006-04-26 09:21:50 UTC (rev 112)
@@ -2,4 +2,5 @@
 <nav>
  <page><title>Home</title><file>index</file></page>
  <page><title>Downloads</title><file>downloads</file></page>
+ <page><title>Documentation</title><file>doc/trunk/html/index</file></page>
 </nav>



From zxombie at berlios.de  Wed Apr 26 11:27:26 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 26 Apr 2006 11:27:26 +0200
Subject: [Libpkg-svn] r113 - www
Message-ID: <200604260927.k3Q9RQJX007473@sheep.berlios.de>

Author: zxombie
Date: 2006-04-26 11:27:26 +0200 (Wed, 26 Apr 2006)
New Revision: 113

Modified:
   www/Makefile
Log:
Fix the www build when nav.xml changes


Modified: www/Makefile
===================================================================
--- www/Makefile	2006-04-26 09:21:50 UTC (rev 112)
+++ www/Makefile	2006-04-26 09:27:26 UTC (rev 113)
@@ -16,4 +16,4 @@
 downloads.html: downloads.xml page.xsl
 	xsltproc downloads.xml > downloads.html
 
-index.xsl: nav.xml
+page.xsl: nav.xml



From zxombie at berlios.de  Wed Apr 26 11:31:33 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 26 Apr 2006 11:31:33 +0200
Subject: [Libpkg-svn] r114 - www
Message-ID: <200604260931.k3Q9VX5M008031@sheep.berlios.de>

Author: zxombie
Date: 2006-04-26 11:31:32 +0200 (Wed, 26 Apr 2006)
New Revision: 114

Modified:
   www/Makefile
Log:
Fix a bug where it would update *.html with BSD make but not GNU make when nav.xml has changed


Modified: www/Makefile
===================================================================
--- www/Makefile	2006-04-26 09:27:26 UTC (rev 113)
+++ www/Makefile	2006-04-26 09:31:32 UTC (rev 114)
@@ -10,10 +10,10 @@
 clean:
 	rm -fr *.html
 
-index.html: index.xml page.xsl
+index.html: index.xml page.xsl nav.xml
 	xsltproc index.xml > index.html
 
-downloads.html: downloads.xml page.xsl
+downloads.html: downloads.xml page.xsl nav.xml
 	xsltproc downloads.xml > downloads.html
 
 page.xsl: nav.xml



From zxombie at berlios.de  Wed Apr 26 12:33:43 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Wed, 26 Apr 2006 12:33:43 +0200
Subject: [Libpkg-svn] r115 - www
Message-ID: <200604261033.k3QAXhcN018865@sheep.berlios.de>

Author: zxombie
Date: 2006-04-26 12:33:40 +0200 (Wed, 26 Apr 2006)
New Revision: 115

Modified:
   www/index.xml
Log:
Update main www page


Modified: www/index.xml
===================================================================
--- www/index.xml	2006-04-26 09:31:32 UTC (rev 114)
+++ www/index.xml	2006-04-26 10:33:40 UTC (rev 115)
@@ -6,12 +6,9 @@
   <h2>About</h2>
   <p>libpkg is a library to fetch, install, remove and modify packages in a
     package management system.</p>
-  <p>It is initialy designed for FreeBSD but could be extennded for any
+  <p>It is initialy designed for FreeBSD but could be extended for any
     system.</p>
-
-  <h2>Todo</h2>
-  <ul>
-   <li>Create a better website</li>
-  </ul>
+  <p>Visit the <a href="http://developer.berlios.de/projects/libpkg/">
+   Berlios summary page</a> for more information.</p>
  </body>
 </page>



From zxombie at berlios.de  Sat Apr 29 09:16:32 2006
From: zxombie at berlios.de (zxombie at BerliOS)
Date: Sat, 29 Apr 2006 09:16:32 +0200
Subject: [Libpkg-svn] r116 - trunk/src
Message-ID: <200604290716.k3T7GWfL025150@sheep.berlios.de>

Author: zxombie
Date: 2006-04-29 09:16:19 +0200 (Sat, 29 Apr 2006)
New Revision: 116

Modified:
   trunk/src/pkg.c
   trunk/src/pkg.h
   trunk/src/pkg_freebsd.c
Log:
Rename the pkg Doxygen group to pkg
Add struct pkg and the enum from pkg.h to the Package group docs


Modified: trunk/src/pkg.c
===================================================================
--- trunk/src/pkg.c	2006-04-26 10:33:40 UTC (rev 115)
+++ trunk/src/pkg.c	2006-04-29 07:16:19 UTC (rev 116)
@@ -34,8 +34,8 @@
 #include "pkg_private.h"
 
 /**
- * @defgroup pkg_internal Internal package functions
- * @ingroup pkg
+ * @defgroup PackageInternal Internal package functions
+ * @ingroup Package
  * @brief Internal functions in the package module
  *
  * None of the callbacks for any given package format need to be specified.
@@ -170,7 +170,7 @@
  */
 
 /**
- * @defgroup pkg Package manipulation Functions
+ * @defgroup Package Package manipulation Functions
  * 
  * These are the publicly availiable package manipulation functions.
  *

Modified: trunk/src/pkg.h
===================================================================
--- trunk/src/pkg.h	2006-04-26 10:33:40 UTC (rev 115)
+++ trunk/src/pkg.h	2006-04-29 07:16:19 UTC (rev 116)
@@ -55,9 +55,19 @@
 char 		*pkg_file_get_name(struct pkg_file *);
 int		 pkg_file_free(struct pkg_file *);
 
+/**
+ * @addtogroup Package
+ *
+ * @{
+ */
+
 /*
  * The package handling functions
  */
+
+/**
+ * @struct pkg pkg.h <pkg.h>
+ */
 struct pkg;
 
 typedef enum {
@@ -88,4 +98,8 @@
 int			  pkg_list_free(struct pkg **);
 int			  pkg_free(struct pkg *);
 
+/**
+ * @}
+ */
+
 #endif /* __LIBPKG_PKG_H__ */

Modified: trunk/src/pkg_freebsd.c
===================================================================
--- trunk/src/pkg_freebsd.c	2006-04-26 10:33:40 UTC (rev 115)
+++ trunk/src/pkg_freebsd.c	2006-04-29 07:16:19 UTC (rev 116)
@@ -92,7 +92,7 @@
 
 /**
  * @defgroup FreebsdPackage FreeBSD Package
- * @ingroup pkg
+ * @ingroup Package
  *
  * @{
  */



